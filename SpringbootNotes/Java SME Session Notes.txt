Java
 

1. J2SE - Java 2 Standard Edition - system/networking oriented project

2. J2EE - Java 2 Enterprise Edition - web oriented appl

3. J2ME - Java 2 Mobile/Micro Edition - mobile based appl

 

Sun Microsystem - Now it is taken by Oracle

late 1980 - Oak

early 1990 - Java - James Gosling, Chris Wirth, Patrick Naughton

 

JDK1.0 - Oak

JDK2.0 - Playground

JDK3.0 - Kestrel

4.0 - Mustang

5.0 - Tiger

7.0 - Dolphin

8.0 - Spyder

 

Fully OOP - Scala

 

C                                                  Java

1. Procedural lang                           1. Partially OOPS

2. Header files                              2. No header files instead we use

#include<stdio.h>                            Packages - folder which contains

#include<math.h>                             collection of class files

                                               import java.io.*;

                                               import java.io.File;

                                               import java.util.*;

                                               import java.lang.*;

 

3. 32 keywords                               3. 51 Keywords

                                              no - sizeof, extern, register,                                                                                              signed, unsigned

 

4. Primitive datatype,                       4. Only primitive datatype

   user defined datatype 

 

5. #define A 40                              5. No global declaration in java

       Macros

 

6. Pointers                                  6. No Pointers

 

function - exists independently

method - exist inside class

 

C++                                           Java

1. Partially OOP                             1. Partially OOP

 

a. object - real world entity, contain memory reference or address

b. class - template/blueprint

         - class variables, methods and constructors

         - access the class by creating an object

c. Encapsulation - wrapping of data into single unit(ie) class

                 - Data hiding/Information hiding

                 - class contain private variables and public methods

d. Abstraction - without knowing the background details of tbe class, we are using that class

e. Inheritance - accessing the properties of one class into another class

               - code reusability

In C++, single, multiple,                   In java, we dont have multiple

multi level, hybrid,                        inheritance instead we have

hiearchial                                  Interface

 

f. Polymorphism - one class which takes many forms - 2 types

1. Static/Compile time polymorphism - using overloading

In C++, we have method, constructor         In Java, we cant overload operator

and operator overloading

2. Dynamic/Runtime polymorphism - using overriding - only Method overriding

 

2. Constructor

      - What is constructor?

            - Whenever we create an object for a class, memory will be allocated and allocation of memory is called constructor

      - When constructor invoked?

             - Whenever we create an object for a class, the constructor will be invoked

      - Why constructor?

             - used to initialize values to the variable at time of object creation

      - By default all class will contain one default constructor (ie) constuctor without any parameter, and we can create our own constructor where ur class name and constructor name should be same, at that time the already present default constructor will be overlap

      - Constructor can be created with or without parameters

      - Constructor can have access specifiers

      - Constructor should not have return type

 

class Box {

     Box() {  //default constructor

 

     }

     void Box(){   //method

     }

}

 

3. Destructor                                3. No destructor, instead we have

      - Deallocation of memory               - Automatic garbage collection

      - ~(tilde) operator                    - System.gc()/Runtime.gc() where

                                              it will internally call                                              finalize() which is used to

                                             deallocate the resource and

                                             invoked only once in lifecycle of

                                              program

 

4. String is a datatype                      4. String is a class/literal

 

Fundamental of Java

1. Identifiers

       - name given for class, methods and variables

       - should always starts with char, con contain digits, special char ($,_) allowed

 

Java Coding standard

1. class - starting letter of each word should be capital letter

      eg: ExampleProgram, SampleController

2. methods - camelcase, from 2nd word onwards each starting letter should be capital

      eg: getAge(), getNameOfEmployee()

3. variables - all lowercase

4. Constants - all uppercase

 

Formatted - ctrl+A - Ctrl+shift+F

 

2. Keywords

        - 51 keywords

        - goto and const are the keywords of Java, but when we use it gives compilation error

         goto - continue

         const - final

        - 3 reserved words - true, false, null

               boolean b1=true;

               boolean b2=false;

              object = null

           

3. Datatypes

       - what type of value stored in a variable

 

datatype       byte        min            max

1. byte          1        -2^7          (2^7)-1    -128 to 127

2. short         2        -2^15         (2^15)-1
3. int           4        -2^31         (2^31)-1
4. long          8        -2^63         (2^63)-1
5. float         4          -             -

6. double        8          -             -

7. char          2(16 bit   0             65535

            unsigned integer)        

8. boolean       1          false         true

 

4. Literal

      - how we can define the value into a variable

 

a. Numeric literal - 3 ways to represent number in java

     1. Decimal literal - base 10

             int a=34;

             int b=27363;

     2. Octal literal - base 8 - always precedded with 0

             int a=01;   //1
             int b=02;   //2

                   03,04,05,06,07

             int c=010;  //8

                     0*8^0=0

                     1*8^1=8

                     0*8^2=0

             int d=011;  //9

                     1*8^0=1
                     1*8^1=8

                     0*8^2=0

             int e=012;  //10

                     2*8^0=2

                     1*8^1=8

                     0*8^2=0

     3. Hexadecimal literal - base 16 - always precedded with 0x or 0X

                  int a=0x16;   //22

                             6*16^0=6

                             1*16^1=16

 

b. short literal

      short s1=10;   //correct

      short s2=10s;  //error

      short s3=10S;  //error

 

c. Long literal

      long l1=10;   //correct

      long l2=10l;  //correct

      long l3=10L;  //correct

 

By default in Java, all +ve or -ve number it is considerd as int datatype

 

d. Float literal

      float f1=3.14;   //error

      float f2=3.14f;  //correct

      float f3=3.14F;  //correct

 

e. Double literal

      double d1=3.14; //correct

      double d2=3.14d; //correct

      double d3=3.14D; //correct

 

By default in Java, all decimal number it is considerd as double datatype

 

f. Boolean literal

      boolean b1=true;  //correct

      boolean b2=false; //correct

      boolean b3=True;  //error

 

g. char literal - single char single quotes

      char c1='a';  //correct

      char c2="a";  //error

      char c3='ab';  //error

      char c4="ab"; //error

      char c5=23;   //correct (prints ascii value for that 23)

      char c6=12733; //correct

      char c7=-45;  //error

      char c8=(char)70000; //correct

 

In Java, char can also be represented as unicode representation

     char c='\u0000';

 

h. String literal - sequence of char with double quotes

         String s1="hello";

 

i. null literal - can be declared only object

        String s1=null;

        Box b=null;

 

5. Variables

       - identifier used to store the value - 2 types

 

int a=10;

 

1. Instance/class variable

        - Any variable that is declared inside the class and outside the method

 

class A {

    int a;  //Instance variable

    void add(){

    }

}

        - No need to initialize instance variable, it will take default value depending on datatype

     int,byte,short,long - 0

     float,double - 0.0

     boolean - false

     char - '\u0000'

     any object - null

 

2. Local variable

       - Any variable that is declared inside the method and complusorly should be initialized otherwise compilation error

 

class A {

    int a;  //Instance variable

    void add(){

       int b=0;  //Local variable

    }

}

 

6. Access specifiers/Access modifiers - 4 types

1. public - it can be accessed anywhere

2. private - it can be accessed only within the class in which it is declared

3. protected - it can be accessible within the class as well as in its inherited class

4. default - if we not specify public or private or protected, then by default it is considered as 
default specifier, it is default access specifier in Java

 

Visibility       default         private        protected         public

1. same pkg         yes            yes              yes             yes

same class

 

2. same pkg         yes            no               yes             yes

different

class

 

3. Different pkg    no             no               yes             yes

subclass

 

4. Different pkg    no             no               no              yes

non subclass

 

7. Type conversion

       - converting from one datatype to another datatypes

 

1. Implicit conversion - automatic conversion from lower to higher datatype

      int a=10;

      double d=a;  //implicit

2. Explicit conversion - conversion from higher to lower datatype

 

int i=128;

byte b=(byte)i;  //explicit    -128 to 127

sop(b);  //-128

 

int i=129;

byte b=(byte)i;  //explicit    -128 to 127

sop(b);  //-127

 

8. Operators

1. Arthimetic operators +,-,*,/

2. Modulus operator %

3. Relational operator >,<,>=,<=

4. Assignment operator =

5. Conditional Assignment operator +=,-=,*=,/=

       a+=2;   a=a+2;

6. Equality and Inequality operator ==,!=

7. Ternary operator ?:

      z=a>b?a:b;

8. Increment and Decrement operator ++,--

9. Bitwise operator - always works on truth table

      & - Bitwise AND

      | - Bitwise OR

      ^ - Bitwise XOR

      ~ - 1's complement

      >> - Right shift - n/2^s

      << - Left shift - n*2^s

 

a=5, b=6;

 

a   b  a&b=4  a|b=7  a^b=3  ~a

0   0   0      0      0      1
1   1   1      1      0      0

0   1   0      1      1      1
1   0   0      1      1      0

 

a=8, b=2

a>>b=8/2^2=8/4=2

a<<b=8*2^2=8*4=32

 

10. Boolean logical operator  a=true, b=false, a&b=?

      & - Logical AND

      | - Logical OR

      ! - Logical NOT

 

11. Shortcircuit logical operator - used to check some condition

          &&   ||

 

if(a>10 && b==1){

 

}

 

12. new operator - used to create an object for the class - 3 ways

 

class Box {

   int a=10;

   void show(){

   }

 

  Box(String s){  //parameterized constructor

 

  }

}

 

1. Box b=new Box();

      - We are creating an object called "b", and we are allocating the memory using 
        new operator and stored inside the object and invokes ur default constructor

 

Box b1=new Box("hello");

 

2. Box b;   //object declaration which contains null reference

   b=new Box();  //creating object, allocate memory, invoke constructor

   b.show();

 

We create object to access method and variable

 

3. new Box();  //allocate and invoke constrcutor

   new Box().show(); //allocate, invoke constructor and call show()

 

13. instanceof operator

        - used to check whether an object is an instance of that class

 

Box b=new Box();

if(b instanceof Box){

   //logic

}






4 J's

 
JDK - Java Development Kit - JDK is JRE + extra tools that are needed to develop java program such as Java compiler, Java interpreter

JVM - Java Virtual Machine - JVM is like motor of car. It is a software that reads and execute the java bytecode

JIT - Just in time compiler - JVM contains JIT, which translate Java byte code into native machine code for the CPU that the prg is running

JRE - Java Runtime Environment - JRE is JVM and everything that is needed to execute java prg by supporting standard libraries, JRE is complete car

Execution Control statement in Java - 3 types




1. Conditional stmt - 2 types

     a.if/if-else/if-else-if/nested if - check for boolean condition

 

In C and C++, other than 0 if we provide +ve or -ve value it will return true otherwise false

     

if(10){   //error

  sop("yes");

}

else

  sop("no")

 

int a=10;

if(a=11){   //error

 

}

if(a==11){  //correct

 

}

 

   b. switch case - check multiple condition

 

Syntax:

     switch(expr) {

         case arg:

            //stmt

            break;

         --

         --

         default:

            //stmt;

            break;

     }

 

- expr can be either int/byte/short/char/enum/String(JDK1.7)

- arg should be always final (ie) acts like constant

 

int a=1;

switch(a) {

  case 1:

     SOP("1");

     break;

  case 1:   //error

 

- default stmt can be present anywhere inside switch case

- If we want to come out from switch we have to use break stmt, dont ever use continue inside switch case,  it leads compilation error

2. Looping statement

 

1. for loop

      for(initialization;condition;inc/dec){

      }

2. do while

      do {

          //stmt

      }

      while(condition);

3  while

      while(condition);

 

3. Flow breaking stmt

1. break - used to stop entire iteration

2. continue - stop the current iteration

3. return - transfer the call back to calling prg

 

public class Main  {

              public static void main(String[] args)  {

                             if(10==10) {

                                           System.out.println("Hello");

                             }

                             if(true)

                                           System.out.println("hi");

                            

                             int a=10;

                             if(a>10)

                                           System.out.println("yes");

                             else

                                           System.out.println("no");

                            

                             switch(10) {

                             case 10:

                                           System.out.println("10");

                                           //break;

                             default:

                                           System.out.println("30");

                                           //break;

                             case 20:

                                           System.out.println("20");

                                           //break;

                             }

                            

                             char c='b';

                             switch(c) {

                             case 'b':

                                           System.out.println("b");

                                           //break;

                             default:

                                           System.out.println("nothing");

                                           break;

                             case 'a':

                                           System.out.println("a");

                                           //break;

                             }

                            

                             String s1="three";

                             switch(s1) {

                             case "one":

                                           System.out.println("10");

                                           //break;

                             default:

                                           System.out.println("30");

                                           //break;

                             case "three":

                                           System.out.println("20");

                                           //break;

                             }

                            

                             for(int i=0;i<10;i++) {

                                           if(i%2==0)

                                                          //break;

                                                          continue;

                                           System.out.println(i+" "); // 1 3 5 7 9

                             }

              }

}

 

Array

   - collection of similar datatypes

 

1. int a[]={1,2,3};  //correct - declaring and initializing the values to the array and its size is fixed depending upon the number of elements, so size=3

2. int a[3]={1,2,3}; //error - if we want to provide the size of array then complusorly we have to new operator

3. int a[]=new int[3];  //correct - declare an array of size 3, memory allocated is 12 bytes(3*4)

4. int[] a=new int[3];  //correct

5. int a[]=new int[]{1,2,3};  //correct - Anonmyous array where we can declare and initialize in same line

6. int a[]=new int[3]{1,2,3}; //error - In anonmyous array u should not specify its size

7. int a[]=new int[-3]; //correct - In Java we can declare an array with negative size but at runtime we get NegativeArraySizeException

8. int a[]=new int[3];  //declaring an array of size 3

   a[0]=1;   a[1]=2;   a[2]=3;  //initalizing an array

9. int a[]={1,2,3};  //

    sop(a); //memory reference

10. We want to access individual elements of array - 2 ways

 

arrayname.length - used to find length of array

i - loopcounter variable

 

1. Normal for loop

 

int a[]={1,2,3};

int i;

for(i=0;i<a.length;i++) {

    System.out.println(a[i]);  //1 2 3

}

 

double d[]={1.2,3.4,5.6};

for(int a1=0;a1<d.length;a1++){

  System.out.println(d[a1]);   //1.2   3.4  5.6

}

 

2. for each stmt - available from JDK1.5 onwards, used to access individual elements of array

 

Syntax: for(countervariable: array){

 

        }

1. counter variable should be declared only inside foreach stmt, and it should be same datatype as a array

2. 1D array has to put inside a variable, 2D array has to put inside 1D, 3D has to put inside 2D etc

 

int a[]={1,2,3};

for(int w: a)

   System.out.println(w);  // 1  2  3

 

double d[]={1.2,3.4,5.6};

for(double d1:d)

   System.out.println(d1); //1.2   3.4   5.6

 

 

1. int a[][]={{1,2},{3,4}};  //correct - declaring and initialize an array 16 bytes(2*2*4)

2. int a[2][2]={{1,2},{3,4}}; //error

3. int a[][]=new int[3][3];  //correct - 36 bytes

4. int[][] a=new int[3][3];  //correct

5. int[] a[]=new int[3][3];  //correct

6. int[][] a=new int[5][5];  //correct - 100 bytes

7. int a[][]=new int[5][5];  //correct - 100 bytes, only 8 bytes remaining 92 bytes will be wasted

     a[0][0]=0;

     a[1][0]=2;

8. int a[][]=new int[5][];  //Correct - Arrays of Array - we have to declare only rows, based on requirment we can allocate ur columns, allocates 16 bytes

    a[0]=new int[1];  a[0][0]=1;

    a[1]=new int[2];  a[1][0]=2;  a[1][1]=3;

    a[2]=new int[1];  a[2][0]=4;

9. int a[][]=new int[][5];  //error

 

 

float f1[][]={{1.2f,3.4f},{4.5f,5.6f}};

sop(f1);  //reference

 

for(int i=0;i<2;i++) {

  for(int j=0;i<2;j++) {

     System.out.println(f1[i][j]);    //1.2  3.4  4.5  5.6

  }

}

 

for(float f2[]:f1)

  for(float f3:f2)

     System.out.println(f3);   //1.2  3.4  4.5  5.6

 

 

2 types of classes

1. Main class

       - entry point of program, there will be always only one mainclass

       - If it is contain public static void main(String[] args)

       - used to create an object for base class and finally we print the output

 

2. Base class

     - we have to write all ur logic inside base class, there may be multiple base class

 

sysout - press ctrl+spacebar

type main - press ctrl+spacebar

 

ctrl A - Ctrl+shift+F - formatting
 	
 

class and object

 

//Base class

class Box {

              //Instance variable

              double width;

              double depth;

              double height;

}

public class Main  {

              public static void main(String[] args)  {

                             Box b1=new Box();  //created an object called "b1" which contains memory reference and invoke default constructor

                             b1.width=10;

                             b1.depth=20;

                             b1.height=15;

                            

                             Box b2=new Box();

                             b2.width=3;

                             b2.depth=6;

                             b2.height=9;

                            

                             double vol;  //local variable

                             vol=b1.width*b1.depth*b1.height;

                             System.out.println("Volume is "+vol); //Volume is 3000.0

                             vol=b2.width*b2.depth*b2.height;

                             System.out.println("Volume is "+vol); //Volume is 162.0

                            

                            

              }

}

 
Method - used to write any logic

Syntax:  returntype methodname(argument)
         {

              //logic

         }

 

//Base class

class Box {

              //Instance variable

              double width;

              double depth;

              double height;

             

              void volume() {

                             System.out.println(width*depth*height);

              }

}

public class Main  {

              public static void main(String[] args)  {

                             Box b1=new Box();  //created an object called "b1" which contains memory reference and invoke default constructor

                             b1.width=10;

                             b1.depth=20;

                             b1.height=15;

                            

                             Box b2=new Box();

                             b2.width=3;

                             b2.depth=6;

                             b2.height=9;

                            

                             b1.volume();  //3000.0

                             b2.volume();  //162.0    

                            

              }

}

 
//Base class

class Box {

              //Instance variable

              double width;

              double depth;

              double height;

             

              double volume() {

                             return (width*depth*height);

              }

}

public class Main  {

              public static void main(String[] args)  {

                             Box b1=new Box();  //created an object called "b1" which contains memory reference and invoke default constructor

                             b1.width=10;

                             b1.depth=20;

                             b1.height=15;

                            

                             Box b2=new Box();

                             b2.width=3;

                             b2.depth=6;

                             b2.height=9;

                             double vol;

                             vol=b1.volume(); 

                             System.out.println("Volume is "+vol);

                             vol=b2.volume();

                             System.out.println("Volume is "+vol);    

              }

}

 

Parameterized Method - method that takes an parameters

 
//Base class

class Box {

              //Instance variable

              double width;

              double depth;

              double height;

             

              double volume() {

                             return (width*depth*height);

              }

             

              void setDim(double w,double d,double h) {

                             width=w;

                             depth=d;

                             height=h;

              }

}

public class Main  {

              public static void main(String[] args)  {

                             Box b1=new Box();  //created an object called "b1" which contains memory reference and invoke default constructor

        b1.setDim(10, 20, 15);                       

                             Box b2=new Box();

                             b2.setDim(3,6,9);

                             double vol;

                             vol=b1.volume(); 

                             System.out.println("Volume is "+vol);

                             vol=b2.volume();

                             System.out.println("Volume is "+vol);

             

              }

}

 

2 types of methods

1. Mutator method - setter method - used to set the value - setSize(), setAge()

2. Accessor method - getter method - used to return the value - getSize(), getAge()

 

Constructor

      - What is constructor?

            - Whenever we create an object for a class, memory will be allocated and allocation of memory is called constructor

      - When constructor invoked?

             - Whenever we create an object for a class, the constructor will be invoked

      - Why constructor?

             - used to initialize values to the variable at time of object creation

      - By default all class will contain one default constructor (ie) constuctor without any parameter, and we can create our own constructor
        where ur class name and constructor name should be same, at that time the already present default constructor will be overlap

      - Constructor can be created with or without parameters

      - Constructor can have access specifiers

      - Constructor should not have return type

 

//Base class

class Box {

              //Instance variable

              double width;

              double depth;

              double height;

             

              double volume() {

                             return (width*depth*height);

              }

             

              Box(){

                             width=-1;

                             depth=-1;

                             height=-1;

              }

}

public class Main  {

              public static void main(String[] args)  {

                             Box b1=new Box();  //created an object called "b1" which contains memory reference and invoke default constructor        

                             Box b2=new Box();

                            

                             double vol;

                             vol=b1.volume(); 

                             System.out.println("Volume is "+vol); //Volume is -1.0

                             vol=b2.volume();

                             System.out.println("Volume is "+vol); //Volume is -1.0

 

              }

}

 

Parameterized Constructor - constructor which takes parameters

  

//Base class

class Box {

              //Instance variable

              double width;

              double depth;

              double height;

             

              double volume() {

                             return (width*depth*height);

              }

             

              Box(double w,double d,double h){   //parameterized constructor

                             width=w;

                             depth=d;

                             height=h;

              }

}

public class Main  {

              public static void main(String[] args)  {

                             Box b1=new Box(10,20,15);  //created an object called "b1" which contains memory reference and invoke default constructor           

                             Box b2=new Box(1,2,3);

                            

                             double vol;

                             vol=b1.volume(); 

                             System.out.println("Volume is "+vol); //Volume is 3000.0

                             vol=b2.volume();

                             System.out.println("Volume is "+vol); //Volume is 6.0

 

              }

}

 

this keyword

    - used to refer current class variable

    - It is used if ur parameter name and instance variable name are same

 

//Base class

class Box {

              //Instance variable

              double width;

              double depth;

              double height;

             

              double volume() {

                             return (width*depth*height);

              }

             

              Box(double width,double depth,double height){   //parameterized constructor

                             this.width=width;

                             this.depth=depth;

                             this.height=height;

              }
}

Handson

 

1. Create a class named Venue with the following member variables / attributes (Default access)

Data Type           Variable Name

String              name

String              city

 

Create another class called Main and write a main method to test the above class.

 

Input and Output Format:

 Refer sample input and output for formatting specifications.

All text in bold corresponds to input and the rest corresponds to output.

 

Sample Input and Output :

Enter the venue name

M. A. Chidambaram Stadium

Enter the city name

Chennai

Venue Details :

Venue Name : M. A. Chidambaram Stadium

City Name : Chennai

 

 

2. Create a class named Player with the following  member variables / attributes  (Default access)

Data Type           Variable Name

String              name

String              country

String                    skill

 

Create another class named Main and write a main method to test the above class.

 

  Input and Output Format:

 Refer sample input and output for formatting specifications.

All text in bold corresponds to input and the rest corresponds to output.

 

Sample Input and Output :

Enter the player name

MS Dhoni

Enter the country name

India

Enter the skill

All Rounder

Player Details :

Player Name : MS Dhoni

Country Name : India

Skill : All Rounder

 

 

 

3. Create a class named Delivery with the following public member variables / attributes

Data Type           Variable Name

Long                over

Long                ball

Long                runs

String              batsman

String              bowler

String              nonStriker

 

 

Include a method in the class named displayDeliveryDetails(). In this method, display the details of the 
delivery in the format shown in the sample output. This method does not accept any arguments and its return type is void.


Create another class called Main  and write a main method to test the above class.


  Input and Output Format:

 Refer sample input and output for formatting specifications.

All text in bold corresponds to input and the rest corresponds to output.

 

Sample Input and Output :

Enter the over

1

Enter the ball

1

Enter the runs

4

Enter the batsman name

MS Dhoni

Enter the bowler name

Dale steyn

Enter the nonStriker name

Suresh Raina

Delivery Details :

Over : 1

Ball : 1

Runs : 4

Batsman : MS Dhoni

Bowler : Dale steyn

NonStriker : Suresh Raina

 

4. Create a class named Player with the following member variables / attributes (default access)

Data Type           Variable Name

String    name

String    country

String    skill

 

Create another class called Main and write a main method to get the player details in a string seperated by comma.
Use String. split() function to display the details.

 

Input and Output Format:

Refer sample input and output for formatting specifications.

All text in bold corresponds to input and the rest corresponds to output.

 

Sample Input and Output :

Enter the player details

MS Dhoni,India,All Rounder

Player Details

Player Name : MS Dhoni

Country Name : India

Skill : All Rounder

 

 

 

5. Create a class named Venue with the following private member variables / attributes

String name

String city

 

Include appropriate getters and setters.

[Naming Convention:

getters : getName getCity...

setters : setName setCity...]

 

Create another class and write a main method to test the above class. In the main method, get the choice from the 
user and update the corresponding venue details.

 

Input and Output Format:

 Refer sample input and output for formatting specifications.

All text in bold corresponds to input and the rest corresponds to output.

  

Sample Input and Output :

Enter the venue name

Green Park Stadium

Enter the city name

Kanpur

Venue Details

Venue Name : Green Park Stadium

City Name : Kanpur

Verify and Update Venue Details

Menu

1.Update Venue Name

2.Update City Name

3.All informations Correct/Exit

Type 1 or 2 or 3

2

Enter the city name

Chennai

Venue Details

Venue Name : Green Park Stadium

City Name : Chennai

Verify and Update Venue Details

Menu

1.Update Venue Name

2.Update City Name

3.All informations Correct/Exit

Type 1 or 2 or 3

1

Enter the venue name

Chidambaram Stadium

Venue Details

Venue Name : Chidambaram Stadium

City Name : Chennai

Verify and Update Venue Details

Menu

1.Update Venue Name

2.Update City Name

3.All informations Correct/Exit

Type 1 or 2 or 3

3

Venue Details

Venue Name : Chidambaram Stadium

City Name : Chennai

 

6.           Venue Details

[Note :

Strictly adhere to the object oriented specifications given as a part of the problem statement.

Use the same class names and member variable names.

Follow the naming conventions mentioned for getters / setters.

Create 3 separate classes in 3 separate files.]

 

Create a class named Venue with the following private member variables / attributes

Data Type           Variable Name

String               name

String               city

 

Include appropriate getters, setters and constructors.

Naming Convention :

getters --- getName,etc...

setters --- setName,etc...

 

Include a default constructor.

Include a 2-argument constructor --- the 1st argument corresponds to the name and the 2nd argument corresponds to the city.

 

Override the toString() method to display the venue details in the following format specified in the output.

 

 

Create a class named VenueBO and include the following methods

No         Method Name                             Method Description

1            void displayVenueDetails(Venue venue) In this method, display the                                                 details of  the venue.

 

 

 

Input and Output Format:

 

Refer sample input and output for formatting specifications.

All text in bold corresponds to input and the rest corresponds to output.

Note : The statement " Venue Details" in the output is displayed in the method inside the BO class.

Sample Input and Output :

Enter the venue name

M Chidhambaram Stadium

Enter the city name

Chennai

Venue Details

M Chidhambaram Stadium,Chennai

 

 

this()  constructor

    - used to invoke different constructor of the same class, it should be always present only in the first line otherwise it gives compilation error

 

class A {

              A(){

                             System.out.println("1");

              }

              A(int a){

                             this("hello");

                             System.out.println("2");

              }

              A(String s){

                             this();

                             System.out.println("3");

              }

}

public class Main  {

              public static void main(String[] args)  {

                             //A a1=new A();

                             A a2=new A(10); //1 3 2

                             //A a3=new A("hello");

              }

}

 

class A {

              A(){

                             this(5);

                             System.out.println("1");

              }

              A(int a){

                             this("hello");

                             System.out.println("2");

              }

              A(String s){

                             System.out.println("3");

              }

}

public class Main  {

              public static void main(String[] args)  {

                             A a1=new A();

                             //A a2=new A(10); //3 2 1

                             //A a3=new A("hello");

              }

}

 

Polymorphism - one class which takes many forms - 2 types

 

1. static/compile time polymorphism

2. Dynamic/runtime polymorphism

 

Static/Compile time polymorphism

     - Using overloading

     - 2 types - Method overloading and Constructor overloading

 

Method overloading

     - same method name, but different number, order and datatype of argument, different return type but present in same class

 

class OverloadDemo {

              //Method overloading

              void test() {

                             System.out.println("No parameter");

              }

              /*void test(int a) {

                             System.out.println("a = "+a);

              }*/

              void test(int a,int b) {

                             System.out.println("a = "+a+" b= "+b);

              }

              double test(double a) {

                             System.out.println("a = "+a);

                             return a*a;

              }

}

public class Main  {

              public static void main(String[] args)  {

                OverloadDemo ob=new OverloadDemo();

                ob.test();

                ob.test(10);  //implicit conversion

                ob.test(10,20);

                double r=ob.test(10.34);

                System.out.println(r);

              }

}

 

Constructor overloading

     - same constructor name, but different number, order and datatype of argument, but present in same class

class Box {

              double width;

              double depth;

              double height;

             

              double volume() {

                             return width*depth*height;

              }

             

              //Constructor Overloading

              Box(){

                             width=-1;

                             depth=-1;

                             height=-1;                        

              }

              Box(double width,double depth,double height){

                             this.width=width;

                             this.depth=depth;

                             this.height=height;

              }

              Box(double len){

                             width=depth=height=len;

              }

}

public class Main  {

              public static void main(String[] args)  {

                  Box b1=new Box();

                  Box b2=new Box(10,20,15);

                  Box b3=new Box(7);

                  double vol;

                  vol=b1.volume();

                  System.out.println("Volume is "+vol); //Volume is -1

                  vol=b2.volume();

                  System.out.println("Volume is "+vol); //Volume is 3000.0

                  vol=b3.volume();

                  System.out.println("Volume is "+vol); //Volume is 343.0

              }

}

 

 

Passing an object as an argument

 

void add(int a){}

void add(Test t){}

void add(Sample s){}

 

class Box {

              double width;

              double depth;

              double height;

             

              double volume() {

                             return width*depth*height;

              }

             

              //Constructor Overloading

              Box(){
	
                             width=-1;

                             depth=-1;

                             height=-1;                        

              }

              Box(double width,double depth,double height){

                             this.width=width;

                             this.depth=depth;

                             this.height=height;

              }

              Box(double len){

                             width=depth=height=len;

              }

              Box(Box b){

                             width=b.width;

                             depth=b.depth;

                             height=b.height;

              }

}

public class Main  {

              public static void main(String[] args)  {

                  Box b1=new Box();

                  Box b2=new Box(10,20,15);

                  Box b3=new Box(7);

                  Box b4=new Box(b2);

                  double vol;

                  vol=b1.volume();

                  System.out.println("Volume is "+vol); //Volume is -1

                  vol=b2.volume();

                  System.out.println("Volume is "+vol); //Volume is 3000.0

                  vol=b3.volume();

                  System.out.println("Volume is "+vol); //Volume is 343.0

                  vol=b4.volume();

                  System.out.println("Volume is "+vol); //Volume is 3000.0

              }

}

 

class Example {

     void add(int a,int b){

        sop(a+b);

     }

     void add(int a,int b, int c){

        sop(a+b+c);

     }

     void add(int a,int b,int c, int d){

        sop(a+b+c+d);

     }

     void add(int a,int b,int c, int d,int e){

        sop(a+b+c+d+e);

     }

}

 

var args

   - used to define variable number of argument, 0 to any

   - Available from JDK1.5 onwards

   - denoted by ...

   - If we are passing combination of arg with var arg, then var arg should be always present only as last arg

   - One method can have only one var args and that also should be present as last argument

 

void add(int...a){  //0 or any number of int arg

 

}

void add(String...s){}  //0 or any number of string arg

 

void add(double...d,String s){}  //error

 

void add(int a,String...s,float...f){}  //error

 

class Demo {

              void add(int...a) {

                             for(int a1:a)

                                           System.out.println(a1);

              }

              void add(boolean...b) {

                             for(boolean b1:b)

                                           System.out.println(b1);

              }

              void add(String s,double...d) {

                             System.out.println(s);

                             for(double d1:d)

                                           System.out.println(d1);

              }

}

public class Main  {

              public static void main(String...args)  {

                 Demo d=new Demo();

                 //d.add();

                 d.add(2,3,4,5);

                 d.add(1,2,3,4,5,6,7,8,9);

                 d.add(true,false,true,true,false);

                 d.add("hello",1.2,3.4,5.6);

              }

}

 

Access specifiers - public, private, protected, default - can be applied for all (ie) class, interface, method, variables, constants

 

Non access specifiers - It has its own restrictions (ie) cannot be applied for everything

 

static keyword

    - It is a non access specifier

    - Whenever a class is declared as static, there is no need to create an object for that class,
      outer class cannot be declared as static only inner class can be static

 

class A  {  //outer class

   class B {  //inner class

   }

}

    - Whenever a method is declared as static, if it is present in same class then we can access using "methodname", if it is present in different class then we can access using "classname.methodname"

    - Whenever a variable is declared as static it will acts like global variable, if it is present in same class then we can access using "variablename", if it is present in different class then we can access using "classname.variablename"

    - static method can access only static content, if it is not static it is accessed by creating an object

 

class Sample {

   int a;

   public static void main(String[] args){

      System.out.println(a);   //compilation error,static method can access only static content

   }

}

 

class Sample {

   static int a;

   boolean b;

   public static void main(String[] args){

      System.out.println(a);  //0

      Sample s=new Sample();

      System.out.println(s.b); //false

   }

}

 

    - When we want to execute any task before main(), then we can go for static block which will be executed before main() method

Syntax:

      static {

         //stmt

      }

     - static method can override only another static method

 

 

public class Main  {

              static int a=4;

              static int b;

             

              static void method(int x) {

                             System.out.println(x); //10

                             System.out.println(a); //4

                             System.out.println(b); //8

              }

             

              static {

                             System.out.println("Static block initialized");

                             b=a*2;

              }

              public static void main(String...args)  {

                   method(10);

              }

}

 

 

class Sample {

              static int a=10;

              static int b=15;

              static void add() {

                             System.out.println(a);

              }

}

public class Main  {

              public static void main(String...args)  {

                   Sample.add(); //10

                   System.out.println(Sample.b); //15

              }

}

 

System.out.println()/System.in

 

System is a predefined class

 

out is an object of PrintStream class and it is static variable in System class

 

println() method of PrintStream class

 

public class System {

     static PrintStream out;

     static InputStream in;

}

 

static import

    - Available from JDK1.5 onwards, only for static method and static variables

    - Normally we can invoke static method and static variable using classname.methodname and classname.variablename, 
      but if we want to invoke static method and static variable without classname.methodname and classname.
      variablename then we can use static import

 

public class Main  {

              public static void main(String...args)  {

                 double d=Math.sqrt(16);

                 System.out.println(d);

              }

}

 

import static java.lang.System.out;

import static java.lang.Math.sqrt;

 

public class Main  {

              public static void main(String...args)  {

                 double d=sqrt(16);

                 out.println(d);

              }

}

 

Nested class and Inner class

    - A class inside another class

 

//Nested class

class A  {

   class B {

   }

}

    - Inside class can be either static or non-static

 

class A  {

   class B { //inner class - non static inner class

   }

}

 

class A  {

   static class B { //static class

   }

}

   - Outer class properties can be accessed inside inner class only if it is instance variable or should be declared as final, otherwise it is an error

   - We cant access inner class properties in outer class

 

class Outer{

              int outer=10;   //Instance variable

             

              void test() {

                             Inner i=new Inner();

                             i.display();

              }

              class Inner {   //Inner class

                             int y=5;

                             void display() {

                                           System.out.println(y+" "+outer);

                             }

              }

             

}

public class Main  {

              public static void main(String...args)  {

                Outer o=new Outer();

                o.test();

              }

}

 

 

class Outer{

              int outer=10;   //Instance variable

 

              class Inner {   //Inner class

                             int y=5;

                             void display() {

                                           System.out.println(y+" "+outer);

                             }

              }

             

}

public class Main  {

              public static void main(String...args)  {

                 Outer.Inner o=new Outer().new Inner();

                 o.display();

              }

}

 

 

class Outer{

              static int outer=10;   //Instance variable

 

              static class Inner {   //static class

                             int y=5;

                             void display() {

                                           System.out.println(y+" "+outer);

                             }

              }

             

}

public class Main  {

              public static void main(String...args)  {

                 Outer.Inner o=new Outer.Inner();

                 o.display();  

              }

}

 

Inheritance

     - accessing the properties of one class into another class if it is not present

      - code reusability

      - using "extends" keyword

      - single, multilevel, hybrid, hiearchial

      - No multiple inheritance

 

class Parent {  //Parent/Base/Super class

}

class Child extends Parent {  //child/derived/sub class

}

 

//Base class - Single inheritance

class Box {

              double width;

              double depth;

              double height;

             

              double volume() {

                             return width*depth*height;

              }

             

              Box() {

                             width=-1;

                             depth=-1;

                             height=-1;

              }

              Box(double w,double d,double h){

                             width=w;

                             depth=d;

                             height=h;

              }

              Box(double len){

                             width=depth=height=len;

              }

              Box(Box ob){

                             width=ob.width;

                             depth=ob.depth;

                             height=ob.height;

              }

}

//Derived class

class BoxWeight extends Box {

              double weight;

             

              BoxWeight(){

                             width=-1;

                             depth=-1;

                             height=-1;

                             weight=-1;

              }

              BoxWeight(double w,double d,double h,double we){

                             width=w;

                             depth=d;

                             height=h;

                             weight=we;

              }

              BoxWeight(double len,double w){

                             width=depth=height=len;

                             weight=w;

              }

              BoxWeight(BoxWeight ob){

                             width=ob.width;

                             depth=ob.depth;

                             height=ob.height;

                             weight=ob.weight;

              }

             

}

public class Main  {

              public static void main(String...args)  {

                   BoxWeight b1=new BoxWeight();

                   double vol;

                   vol=b1.volume();

                   System.out.println("Volume is "+vol); //Volume is -1.0

                   System.out.println("Weight is "+b1.weight);

                   

                   BoxWeight b2=new BoxWeight(10,20,15,3);

                   vol=b2.volume();

                   System.out.println("Volume is "+vol); //Volume is 3000.0

                   System.out.println("Weight is "+b2.weight); //3
                  

                   BoxWeight b3=new BoxWeight(10,20);

                   vol=b3.volume();

                   System.out.println("Volume is "+vol); //Volume is 1000.0

                   System.out.println("Weight is "+b3.weight); //20

                  

                   BoxWeight b4=new BoxWeight(b1);

                   vol=b4.volume();

                   System.out.println("Volume is "+vol); //Volume is -1.0

                   System.out.println("Weight is "+b4.weight); //-1

              }

}

 

super keyword

    - used to access base class constructor, base class method and base class variable.

    - Only in the case accessing base class constructor, super keyword should be present in first line

    - super() and this() cant be used simultaneously

 

//Base class - Single inheritance

class Box {

              private double width;

              private double depth;

              private double height;

             

              double volume() {

                             return width*depth*height;

              }

             

              Box() {

                             width=-1;

                             depth=-1;

                             height=-1;

              }

              Box(double w,double d,double h){

                             width=w;

                             depth=d;

                             height=h;

              }

              Box(double len){

                             width=depth=height=len;

              }

              Box(Box ob){

                             width=ob.width;

                             depth=ob.depth;

                             height=ob.height;

              }

}

//Derived class

class BoxWeight extends Box {

              double weight;

             

              BoxWeight(){

                             super();

                             weight=-1;

              }

              BoxWeight(double w,double d,double h,double we){

                             super(w,d,h);

                             weight=we;

              }

              BoxWeight(double len,double w){

                             super(len);

                             weight=w;

              }

              BoxWeight(BoxWeight ob){

                             super(ob);

                             weight=ob.weight;

              }

             

}

public class Main  {

              public static void main(String...args)  {

                   BoxWeight b1=new BoxWeight();

                   double vol;

                   vol=b1.volume();

                   System.out.println("Volume is "+vol); //Volume is -1.0

                   System.out.println("Weight is "+b1.weight); //-1

                  

                   BoxWeight b2=new BoxWeight(10,20,15,3);

                   vol=b2.volume();

                   System.out.println("Volume is "+vol); //Volume is 3000.0

                   System.out.println("Weight is "+b2.weight); //3
                  

                   BoxWeight b3=new BoxWeight(10,20);

                   vol=b3.volume();

                   System.out.println("Volume is "+vol); //Volume is 1000.0

                   System.out.println("Weight is "+b3.weight); //20

                  

                   BoxWeight b4=new BoxWeight(b1);

                   vol=b4.volume();

                   System.out.println("Volume is "+vol); //Volume is -1.0

                   System.out.println("Weight is "+b4.weight); //-1

              }

}

 

//Base class - Multilevel inheritance

class Box {

              private double width;

              private double depth;

              private double height;

             

              double volume() {

                             return width*depth*height;

              }

             

              Box() {

                             width=-1;

                             depth=-1;

                             height=-1;

              }

              Box(double w,double d,double h){

                             width=w;

                             depth=d;

                             height=h;

              }

              Box(double len){

                             width=depth=height=len;

              }

              Box(Box ob){

                             width=ob.width;

                             depth=ob.depth;

                             height=ob.height;

              }

}

//Derived class

class BoxWeight extends Box {

              double weight;

             

              BoxWeight(){

                             super();

                             weight=-1;

              }

              BoxWeight(double w,double d,double h,double we){

                             super(w,d,h);

                             weight=we;

              }

              BoxWeight(double len,double w){

                             super(len);

                             weight=w;

              }

              BoxWeight(BoxWeight ob){

                             super(ob);

                             weight=ob.weight;

              }

             

}

class Shipment extends BoxWeight {

              double cost;

             

               Shipment(double w,double d,double h,double we,double c){

                             super(w,d,h,we);

                             cost=c;

              }

}

public class Main  {

              public static void main(String...args)  {

                   Shipment s1=new Shipment(10,20,15,3,4);

                   double vol;

                   vol=s1.volume();

                   System.out.println("Volume is "+vol); //3000.0

                   System.out.println("Weight is "+s1.weight);  //3
                   System.out.println("Cost is "+s1.cost); //4

              }

}

 

class A {

              int i;

}

class B extends A {

              int i;

             

              B(int i,int j){

                             this.i=i;   //from B class

                             super.i=j; //from A class

              }

              void show() {

                             System.out.println(i+" "+super.i);

              }

}

public class Main  {

              public static void main(String...args)  {

                 B b=new B(1,2);

                 b.show(); // 1  2

              }

}

 

 

Scanner class

    - used to get input from user based on the datatype

    - present in java.util.*

    - If we use combination of numbers and String, either u can use dummy line called sc.nextLine() or get all input in string 
      (ie) using nextLine() and later convert to its related datatype

 

int nextInt()

float nextFloat()

double nextDouble()

short nextShort()

byte nextByte()

long nextLong()

boolean nextBoolean()

String nextLine() - read words with space

String next() - read single word without space

 

public class Main  {

              public static void main(String...args)  {

                 Scanner sc=new Scanner(System.in);

                 System.out.println("Enter age");

                 int s2=Integer.parseInt(sc.nextLine());

                 //sc.nextLine();

                 System.out.println("Enter name");      

                 String s1=sc.nextLine();

               

                 //Student st=new Student(s1,s2);

                 Student st=new Student();

                 st.setName(s1);

                 st.setAge(s2);

                 System.out.println(st.getName()+" "+st.getAge());

              }

}


Handson

1.           Abstract Class I – Shape

 

[Adhere to the OOPs specifications specified here. Follow the naming conventions for getters and setters.
 Download the template code provided and fill in the missing code]

 

Create an abstract class named Shape with the following protected attributes / member variables.

 

String name

 

 

Include a 1-argument constructor.

 

Include getters and setters.

 

Include an abstract method named calculateArea() . This method returns a Float value.

 

 

 

Create a class named Circle . The class Circle is a derived class of Shape. Include the following private attributes / member variables.

 

Integer radius

 

Include a 2-argument constructor. The order of the arguments is name, radius.

 

Include getters and setters.

 

Override the abstract method calculateArea() defined in the Shape class. This method returns the area of the circle. [Take the value of pi as 3.14]

 

 

 

Create a class named Square . The class Square is a derived class of Shape. Include the following private attributes / member variables.

 

Integer side

 

Include a 2-argument constructor. The order of the arguments is name, side.

 

Include getters and setters.

 

Override the abstract method calculateArea() defined in the Shape class. This method returns the area of the square.

 

 

 

Create a class named Rectangle . The class Rectangle is a derived class of Shape. Include the following private attributes / member variables.

 

Integer length

 

Integer breadth

 

Include a 3-argument constructor. The order of the arguments is name, length, breadth

 

Include getters and setters.

 

Override the abstract method calculateArea() defined in the Shape class. This method returns the area of the rectangle.

 

 

Create another class called Main. In the method, create instances of the above classes and test the above classes.

 

 

Input and Output Format:

 

Refer sample input and output for formatting specifications.

 

All Float values are displayed correct to 2 decimal places.

 

All text in bold corresponds to input and the rest corresponds to output.

 

Sample Input and Output 1:

 

Circle

 

Square

 

Rectangle

 

Enter the shape name

 

Circle

 

Enter the radius

 

25

 

Area of Circle is 1962.50

 

 

Sample Input and Output 2:

 

Circle

 

Square

 

Rectangle

 

Enter the shape name

 

Square

 

Enter the side

 

23

 

Area of Square is 529.0

 

 

Sample Input and Output 3:

 

Circle

 

Square

 

Rectangle

 

Enter the shape name

 

Rectangle

 

Enter the length

 

45

 

Enter the breadth

 

60

 

Area of Rectangle is 2700.00

 

 

2.Abstract Class II – Card

 

[Adhere to the OOPs specifications specified here. Follow the naming conventions for getters and setters. 
Download the template code provided and fill in the missing code]

 

Create an abstract class named Card with the following protected attributes / member variables.

 

String holderName;

 

String cardNumber;

 

String expiryDate;

 

Include appropriate getters and setters.

 

Include appropriate constructors. In the 3-argument constructor, the order of the arguments is holderName, cardNumber, expiryDate.

 

 

 

Create a class named MembershipCard. The class MembershipCard is a derived class of Card. Include the following private attributes / member variables.

 

Integer rating

 

Include appropriate getters and setters.

 

Include appropriate constructors. In the 4-argument constructor, the order of the arguments is holderName, cardNumber, expiryDate, rating.

 

 

 

Create a class named PaybackCard. The class PaybackCard is a derived class of Card. Include the following private attributes / member variables.

 

Integer pointsEarned;

 

Double totalAmount;

 

Include appropriate getters and setters.

 

Include appropriate constructors. In the 5-argument constructor, the order of the arguments is holderName, 
cardNumber, expiryDate, pointsEarned, totalAmount.

 

 

Create another class called Main. In the method, create instances of the above classes and test the above classes.
 The card details are entered separated by a ‘|’.

 

 

Input and Output Format:

 

Refer sample input and output for formatting specifications.

 

All text in bold corresponds to input and the rest corresponds to output.

 

Sample Input and Output 1:

 

Select the Card

 

1.Payback Card

 

2.Membership Card

 

1

 

Enter the Card Details:

 

Anandhi|12345|14/01/2020

 

Enter points in card

 

1000

 

Enter Amount

 

50000

 

Anandhi's Payback Card Details:

 

Card Number 12345

 

Points Earned 1000

 

Total Amount 50000.0

 

Sample Input and Output 2:

 

Select the Card

 

1.Payback Card

 

2.Membership Card

 

2

 

Enter the Card Details:

 

Collin|45678|20/11/2021

 

Enter rating in card

 

10

 

Collin's Membership Card Details:

 

Card Number 45678

 

Rating 10

 

 

3. Simple Interface

 

An Interface consists of a contract of set of methods with only declaration and no implementation. 
Any class which implements the interface commits that all methods would be implemented.

Here is a program to illustrate a simple interface.

 

1. Create an interface IPlayerStatistics

 Add a method with the following prototype

--- public void displayPlayerStatistics

2. Create class Player which implements the IPlayerStatistics Interface

Include private data members :

String name

String teamName

Integer noOfMatches

Long totalRunsScored

Integer noOfWicketsTaken

 

Include an 5 argument constructor with following arguments:  name, teamName, noOfMatches, totalRunsScored, noOfWicketsTaken

and implement the interface method public void displayPlayerStatistics to display the player details.

 

Create a  Main class with main method to test test above classes. 

 

Sample Input and Output 1:

[All text in bold corresponds to input and the rest corresponds to output.]

 

Enter player name

Ravichandran Ashwin

Enter team name

Chennai Super Kings

Enter number of matches played

86

Enter total runs scored

185

Enter number of wickets taken

89

Player Details

Player name : Ravichandran Ashwin

Team name : Chennai Super Kings

No of matches : 86

Total runsscored : 185

No of wickets taken : 89

 

 

4.Interface II

 

1. Create an interface IPlayerStatistics

Add a method with the following prototype

public void displayPlayerStatistics

2. Create base class CricketPlayer

Include private data members : name, teamName, noOfMatches.

Include an 3 argument constructor with following arguments:  name, teamName, noOfMatches.

 

3. Create derived class Bowler  which extends  CricketPlayer and implements the interface  IplayerStatistics

Include private data members :  noOfWickets.

Include an 1 argument constructor with the argument:  noOfWickets and implement the interface 
method public void displayPlayerStatistics to display the player details.

 

4. Create derived  class Batsman  which extends  CricketPlayer and implements the interface  IPlayerStatistics

  Include private data members : runs.

  Include an 1 argument constructor with the argument: runs  and implement the interface method public void 
displayPlayerStatistics to display the player details.

 

5. Create derived class WicketKeeper  which extends  CricketPlayer and implements the interface  IPlayerStatistics

  Include private data members : noOfCatches, noOfStumpings ,runs,    noOfDismissals .

  Include an 4 argument constructor with following arguments:  noOfCatches, noOfStumpings,runs, 
noOfDismissals and implement the interface method public void displayPlayerStatistics to display the player details.

 

6. Create derived class AllRounder  which extends  CricketPlayer and implements the interface  IPlayerStatistics

  Include private data members : runs,noOfWickets.

  Include an 2 argument constructor with following arguments:  runs, noOfWickets  and implement the interface method public 
void displayPlayerStatistics to display the player details.

 

Create a Main class with main method to test test above classes.

 

Input and Output Format:

Refer sample input and output for format specifications.

[All text in bold corresponds to input and the rest corresponds to output.]

 

Sample Input and Output 1:

Menu

1.Bowler

2.Batsman

3.WicketKeeper

4.AllRounder

Enter your choice

1

Enter the Bowler details

Enter player name

Ravichandran Ashwin

Enter team name

Chennai Super Kings

Enter number of matches played

111

Enter number of wickets taken

100

Player name : Ravichandran Ashwin

Team name : Chennai Super Kings

No of matches : 111

No of wickets taken : 100

Do you want to continue?

YES

Menu

1.Bowler

2.Batsman

3.WicketKeeper

4.AllRounder

Enter your choice

4
Enter the AllRounder details

Enter player name

Shane Watson

Enter team name

Royal Challengers Bangalore

Enter number of matches played

94

Enter the runs scored

2551

Enter number of wickets taken

81

Player name : Shane Watson

Team name : Royal Challengers Bangalore

No of matches : 94

Runs scored : 2551

No of wickets taken : 81

Do you want to continue?

NO

 

Sample Input and output 2:

Menu

1.Bowler

2.Batsman

3.WicketKeeper

4.AllRounder

Enter your choice

2

Enter the Batsman details

Enter player name

Virat Kohli

Enter team name

Royal Challengers Bangalore

Enter number of matches played

139

Enter the runs scored

4110

Player name : Virat Kohli

Team name : Royal Challengers Bangalore

No of matches : 139

Runs scored : 4110

Do you want to continue?

YES

Menu

1.Bowler

2.Batsman

3.WicketKeeper

4.AllRounder

Enter your choice

3

Enter the WicketKeeper details

Enter player name

Mahendra Singh Dhoni

Enter team name

Chennai Super Kings

Enter number of matches played

143

Enter number of catches taken

52

Enter number of stumpings

22

Enter number of dismissals

74

Enter the runs scored

3271

Player name : Mahendra Singh Dhoni

Team name : Chennai Super Kings

No of matches : 143

No of catches taken : 52

No of stumpings : 22

No of dismissals : 74

Runs scored : 3271

Do you want to continue?

NO

 

Problem Statement:

What is the output of the following program?

 

class Eggs {   

    int doX(Long x, Long y) { return 1;}

    int doX(long... x) { return 2;}

    int doX(Integer x, Integer y) { return 3; }

    int doX(Number n, Number m) { return 4; }

   

    public static void main(String[ ] args) {

        new Eggs().go();

    }

 

    void go() {

        short s = 7;

        System.out.println(doX(s,s) + " ");

        System.out.println(doX(7,7));

    }

}

 

A.           1  1

B.           2  1

C.           3  1

D.          4  1

E.           2  3

F.           3  3

G.          4  3

 

Problem Statement:

What is the output of the following program?

 

class Mixer {   

    Mixer() { }

    Mixer(Mixer m) { m1 = m; }

    Mixer m1;

    public static void main(String[ ] args) {

        Mixer m2 = new Mixer();

        Mixer m3 = new Mixer(m2);

        m3.go();

        Mixer m4 = m3.m1;

        m4.go();

        Mixer m5 = m2.m1;

        m5.go();

    }

    void go() {

        System.out.println("hi ");

    }

}

 

 

 

Problem Statement:

What is the output of the following program?

 

class Bird {   

    { System.out.print("b1 "); }

   

    public Bird() {

        System.out.print("b2 ");

    }

}

 

class Raptor extends Bird {

    static { System.out.print("r1 "); }

   

    public Raptor() {

        System.out.print("r2 ");

    }

   

    { System.out.print("r3 "); }

   

    static { System.out.print("r4 "); }

}

 

class Hawk extends Raptor {

    public static void main(String[] args) {

        System.out.print("pre ");

        new Hawk();

        System.out.println("hawk ");

    }

}

 

A.           pre b1 b2 r3 r2 hawk

B.           pre b2 b1 r2 r3 hawk

C.           pre b2 b1 r2 r3 hawk r1 r4

D.          r1 r4 pre b1 b2 r3 r2 hawk

E.           r1 r4 pre b2 b1 r2 r3 hawk

F.           pre r1 r4 b1 b2 r3 r2 hawk

G.          pre r1 r4 b2 b1 r2 r3 hawk

H.          The order of output cannot be predicted.

I.            Compilation fails.

 

 

 

Problem Statement:

What is the output of the following program?

 

class Clidders {

    public final void flipper() {

        System.out.println("Clidder");

    }

}

 

public class Clidlets  extends Clidders {

    public void flipper() {

        System.out.println("Flip a Clidlet");

        super.flipper();

    }   

    public static void main(String[] args) {

        new Clidlets().flipper();

    }   

}

 

A.           Flip a Clidlet

B.           Flip  a Clidder

C.           Flip a Clidder

Flip a Clidlet

D.          Flip a Clidlet

Flip a Clidder

E.           Compilation fails.

 

 

Problem Statement:

Given the following:

  i.     interface Base {

ii.         boolean m1 ();

iii.         byte m2(short s);

iv.     }

 

Which code fragments will compile? (Choose all that apply.)

 

a)  interface Base2 implements Base { }

b)  abstract class Class2 extends Base {

    public boolean m1 ()  { return true; }  }

c)  abstract class Class2 implements Base { }

d)  abstract class Class2 implements Base {

   public boolean m1 () { return (true); }  }

e)  class Class2 implements Base {

  boolean m1 () { return false; }

  byte m2 (short s) { return 42; } }

 

 

Problem Statement:

Which of the following declare a compatible abstract class? (Choose all that apply.)

 

a)  public abstract class Canine { public Bark speak(); }

b)  public abstract class Canine { public Bark speak() { } }

c)  public class Canine { public abstract Bark speak(); }

d)  public class Canine abstract { public abstract Bark speak(); }

 

 

 

Problem Statement:

Given:

public abstract interface Frobnicate { public void twiddle(String s); }

 

Which is a correct class?

 

a)  public abstract void twiddle(String s) { }

}

b)  public abstract class Frob implements Frobnicate { }

c)  public class Frob extends Frobnicate {

              public void twiddle(Integer i) { }

}

d)  public class Frob implements Frobnicate {

            public void twiddle(Integer i) { }

}

e)  public class Frob implements Frobnicate {

             public void twiddle(String i) { }

             public void twiddle(Integer s) { }

}

 

 

Problem Statement:

Given:

1.      class Zing {

2.      protected Hmpf h;

3. }

4. class Woop extends Zing {  }

5. class Hmpf { }

 

Which is true?

A.     Woop IS-A Hmpf and HAS-A zing.

B.     Zing IS-A Woop and HAS-A Hmpf.

C.     Hmpf HAS-A Woop and Woop IS-A Zing.

D.    Woop HAS-A Hmpf and Woop IS-A Zing.

E.     Zing HAS-A Hmpf and Zing IS-A Woop.

 

 

Problem Statement:

Given:

            public class MyOuter {

         public static class MyInner {

                    public static void foo() ) { }

                }

           }

Which, if placed in a class other than MyOuter or MyInner, instantiates an instance of the nested class?

A.           MyOuter.MyInner m = new MyOuter.MyInner();

B.           MyOuter.MyInner m2 = new MyInner();

C.           MyOuter m = new MyOuter();

MyOuter.MyInner mi = m.new MyOuter.MyInner();

D.          MyInner mi = new MyOuter.MyInner();

 

Problem Statement:

What is the output of the following program?

 

public abstract class AbstractTest {

   

    public int getNum()) {

        return 45;

    }

    public abstract class Bar {

        public int getNum()) {

            return 38;

        }

   }

    public static void main(String[] args) {

        AbstractTest t = new AbstractTest()) {

            public int getNum()) {

                return 22;

            }

        };

        AbstractTest.Bar f = t.new Bar()) {

            public int getNum()) {x	

                return 57;

            }

        };

        System.out.println()f.getNum()) + " " + t.getNum()));

    }

}

 

A.           57  22

B.           45  38

C.           45  57

D.          An exception occurs at runtime.

E.           Compilation fails.

 

 

 

super keyword

    - It is used to access ur base class constructor, base class method and base class variable

 

class A {

              int i;

              int j;

             

              A(int a,int b){

                             i=a;

                             j=b;

              }

             

              void show() {

                             System.out.println("i= "+i+" j= "+j);

              }

}

class B extends A {

              int k;

             

              B(int a,int b,int c){

                             super(a,b);

                             k=c;

              }

              void show() {

                  super.show();

                             System.out.println("k= "+k);

              }

}

public class Main {

              public static void main(String[] args) {

                             B b=new B(1,2,3);

                             b.show();

              }

}

 

Method overriding

     - same method name, same number,order and datatype of arg, same return type of method and present in different
 class and the class should be inherited

 

No Constructor overriding

 

Dynamic Method Dispatch

       In order to have effective method overriding, we go for Dynamic Method dispatch

       - We always create an object for base class but we store the reference of derived class but not vice versa,
 so the compiler thinks that object is created for base class but only at runtime it comes to know it contains the reference of derived class, 
in this way we achieve runtime polymorphism

 

class Sphere {

              void volume() {

                             System.out.println("Sphere volume");

              }

}

class Hemisphere extends Sphere {

              void volume() {

                             System.out.println("Hemisphere volume");

              }

}

public class Main {

              public static void main(String[] args) {

                             /*Hemisphere h=new Hemisphere();

                             h.volume();  //Hemisphere volume

                             Sphere s=new Sphere();

                             s.volume();*/ //Sphere volume

                            

                             Sphere s=new Hemisphere();  //DMD

                             s.volume();  //Hemisphere volume

                             s=new Sphere();  //Hemisphere reference garbage collected and s contain sphere reference

                             s.volume(); //Sphere volume

              }

}

 

//Hiearchial inheritance

class A {

              void callback() {

                             System.out.println("A's callback implementation");

              }

}

class B extends A {

              void callback() {

                             System.out.println("B's callback implementation");

              }

}

class C extends A {

              void callback() {

                             System.out.println("C's callback implementation");

              }

}

public class Main {

              public static void main(String[] args) {

                             A a=new A();

                             a.callback();

                             a=new B();  //DMD

                             a.callback();

                             a=new C();

                             a.callback();

              }

}

 

 

How constructors are invoked in inheritance?

      - Invoked as top down approach

 

//Multilevel inheritance

class A {

              A() {

                             System.out.println("1");

              }

}

class B extends A {

              B() {

                             System.out.println("2");

              }

}

class C extends B{

              C(){

                             System.out.println("3");

              }

}

public class Main {

              public static void main(String[] args) {

                             C c=new C();  //123

              }

}

 

//Multilevel inheritance

class A {

              A(int a) {

                             System.out.println("1");

              }

}

class B extends A {

              B() {

                             System.out.println("2");

              }

}

class C extends B{

              C(){

                             System.out.println("3");

              }

}

public class Main {

              public static void main(String[] args) {

                             C c=new C();  //compilation error

              }

}

 

First it will go to the related constructor (ie)into C class constructor and check whether we have used super() or this(), 
then it will work according to that, if it is not then by default it will invoke only default constructor of base class

 

//Multilevel inheritance

class A {

              A(int a) {

                             System.out.println("1");

              }

        /*A() {

            System.out.println("4");

        }*/

}

class B extends A {

              B() {

                super(10);

                             System.out.println("2");

              }

}

class C extends B{

              C(){

                             System.out.println("3");

              }

}

public class Main {

              public static void main(String[] args) {

                             C c=new C();   //123

              }

}

 

final keyword

    - It is a non access specifier

    - When a class is declared as final, inheritance is not possible

final class A {

              A() {

                             System.out.println("1");

              }

}

class B extends A {  //error

              B() {

                             System.out.println("2");

              }

}

    - When a method is declared as final, method overriding is not possible

class A {

              final void add() {

                             System.out.println("1");

              }

}

class B extends A { 

              void add() {  //error

                             System.out.println("2");

              }

}

     - When a variable is declared as final, it will acts like constant

 

Relationship - 2 types

1. is a relationship - when we perform inheritance

 

class Animal{

}

class Cat extends Animal{

}

 

Cat is a Animal

 

2. has-a relationship - Composition - one class contains another class

 

class Wheel{

}

class Car{

   Wheel w=new Wheel();    //Car has a Wheel

}

 

Covariant return type

      - Before JDK1.5, it is not possible to override any method by changing its return type

      - From JDK1.5, it is possible to override method by changing its return type (ie) only non primitive (ie) object

      - Avoid type casting, wrong typecasting which leads to ClassCastException at runtime

 

class A {

              A show() {

                             return this;

              }

              void print() {

                             System.out.println("Inside A's method");

              }

}

class B extends A { 

              B show(){

                             return this;

              }

              void print() {

                             System.out.println("Inside's B method");

              }

}

class C extends B { 

              C show(){

                             return this;

              }

              void print() {

                             System.out.println("Inside's B method");

              }

}

public class Main {

              public static void main(String[] args) {

                             A a1=new A();

                             a1.show().print();  //Inside A's method

                             B b1=new B();

                             b1.show().print();  //Inside B's method

              }

}

 

Compound block/Instance block

     - It will be invoked before the constructor invokes

 

Syntax:  {

            //logic

         }

 

only in case inheritance, first all static block will be executed from top to bottom

 

18 21 19 1 6 11 15 17 5 7 2 4 3 8 10 9 14 16 12 13 20

 

class A {

              static {   //static block

                             System.out.println("1");

              }

              A(){

                             System.out.println("2");

              }

              A(String s){

                             this(10);

                             System.out.println("3");

              }

              A(int a){

                             this();

                             System.out.println("4");

              }

              {   //Compound block

                             System.out.println("5");

              }

              static {

                             System.out.println("6");

              }

              {

                             System.out.println("7");

              }

}

class B extends A {

              {

                             System.out.println("8");

              }

              B(){

                             super("hello");

                             System.out.println("9");

              }

              {

                             System.out.println("10");

              }

              static {

                             System.out.println("11");

              }

}

class C extends B {

              C(){

                             System.out.println("12");

              }

              C(int a){

                             this();

                             System.out.println("13");

              }

              {

                             System.out.println("14");

              }

              static {

                             System.out.println("15");

              }

              {

                             System.out.println("16");

              }

              static {

                             System.out.println("17");

              }

}

public class Main {

              static {

                             System.out.println("18");

              }

              public static void main(String[] args) {

                  System.out.println("19");

                  C c=new C(10);

                  System.out.println("20");

              }

              static {

                             System.out.println("21");

              }

}

 

abstract keyword

    - It is a non access specifier

    - When a class is declared as abstract, u cannot create an object for that class

    - When a method is declared as abstract, it does not contain any defination, it just ends with semicolon

    - Variables cant be declared as abstract

    - When a class contains abstract method then that class should be declared as abstract otherwise error, but not necessarlly all 
      abstract class should contain abstract methods

    - Abstract class can also non abstract method (normal method)

    - Abstract class can also be inherited, so when u inherit an abstract class then complusorly 
      we have to provide the defination of abstract method in the inherited class or if we not defining the defination 
      then we have to make inherited class itself as abstract

    - Abstract class contain constrcutor but we cant invoke it



abstract class A {

              abstract void show();

              void method() {

                             System.out.println("Concrete implementation");

              }

}

/*abstract*/ class B extends A {

              void show() {

                             System.out.println("Abstract method");

              }

}

public class Main {

              public static void main(String[] args) {

                 B b=new B();

                 b.show();

                 b.method();

              }

             

}

 

Anonmyous Inner class

    - used to access normal method of abstract class without inheritance

 

abstract class A {

              abstract void show();

              void add() {

                             System.out.println("Concrete implementation");

              }

}



public class Main {

              public static void main(String[] args) {

                  A a=new A() {   //AIC

                            public void show() {

                                           System.out.println("abstract method");

                            }

                            public void add() {

                                           System.out.println("hello");

                            }

                  };

                  a.show();

                  a.add();

              }

             

}

 

Interface

    - No multiple inheritance instead we use interface

    class A extends B,C,D{   //error

    }

    - Interface are syntacially similar to classes but contains only method declaration and variable declaration and initialization

 

Syntax:

    <<accessspecifier>>  interface  interfacename {

         //method declaration

         //variable declaration and initialization

    }

 

    - By default all interfaces are abstract, so we cant create an object for interface

    - By default all interface methods are public and abstract, so interface method dosent contain any defination it just ends with semicolon

    - By default all interface variables are public, final, static, so we can access interface variable using "interfacename.variablename"

    - Using "implements" keyword we can use interface in class

    - When a class implements an interface then complusorly we have to provide the defination of interface method in the class with public 
      access specifier or define the class itself to be abstract

    - The implemented class can also contain non interface method

    - Interface can also be inherited

1 class extends 1 class

1 class implement n interface

1 interface extends n interface

    - Marker interface - interface which dosent contain anything like Cloneable, Serializable, Remote

    - From JDK1.8 onwards, interface can also contain default and static method

    - From JDK1.9 onwards, interface can also contain private and private static methods

 

 

interface Maths {

              void arthimetic(int a,int b);

              int c=10;

}

/*abstract*/ class A implements Maths {

              @Override

              public void arthimetic(int a, int b) {

                             System.out.println(a+b);

                             System.out.println(Maths.c);

              }            

}

class B implements Maths {

              @Override

              public void arthimetic(int a, int b) {

                             System.out.println(a-b);

              }            

}

public class Main {

              public static void main(String[] args) {

                /* A a=new A();

                 a.arthimetic(5, 3);  //8 10

                 B b=new B();

                 b.arthimetic(5, 1); */ //4
                            

                             Maths m=new A();  //DMD

                             m.arthimetic(5, 3);  //8  10

                             m=new B();

                             m.arthimetic(5, 1);  //4
              }

             

}

 

interface A {

              void meth1();

}

interface B {

              void meth2();

}

interface C extends A,B{

              void meth3();

}

class Example implements C {

 

              @Override

              public void meth1() {

                             System.out.println("Meth1");

              }

 

              @Override

              public void meth2() {

                             System.out.println("Meth2");

              }

 

              @Override

              public void meth3() {

                             System.out.println("Meth3");

              }

             

}

public class Main {

              public static void main(String[] args) {

                Example e=new Example();

                e.meth1();

                e.meth2();

                e.meth3();

              }

}

Handson

 

1. Team Details

Create a class named Team with the following private member variables / attributes

             

String name;     

String coach;     

String location; 

String players   

String captain   

 

Include appropriate getters and setters.

[Naming Convention:

getters : getName getCoach ..

setters : setName, setCoach...]

 

Include a 5-argument argument constructor in this class. The arguments passed to the constructor are in this order --- name, coach, location,players,captain.

Include a default empty constructor.

 

Create another class named Main and include a main method to test the above class(Print the output in Main Class).

 

 

Input and Output Format:

Refer sample input and output for formatting specifications.

Read the team details as a string value separate by '#'. Use string.split() function to display the team details

All text in bold corresponds to input and the rest corresponds to output.

 

 

Sample Input and Output :

Enter the team details

CSK#Stephen Fleming#Chennai#MS Dhoni,Aswin,Raina,Hussey,Maxwel,Bravo,Morkel,Jadeja,Mohit Sharma,Hayden,du plessis,Abhinav Mukund#MS Dhoni

Team : CSK

Coach : Stephen Fleming

Location : Chennai

Players : MS Dhoni,Aswin,Raina,Hussey,Maxwel,Bravo,Morkel,Jadeja,Mohit Sharma,Hayden,du plessis,Abhinav Mukund

Captain : MS Dhoni

 

2. Wicket details

 

Create a class named Wicket with the following private member variables / attributes

             

Long over          

Long ball            

String wicketType          

String playerName         

String bowlerName

 

Include a 5-argument argument constructor in this class. The arguments passed to the constructor are in this order --- over, ball,wicketType,playerName,bowlerName.

Include a default empty constructor.

 

Include appropriate getters and setters.

[Naming Convention:

getters : getOver getBall ...

setters : setOver, setBall...]

 

Create another class named Main and include a main method to test the above class(Print the output in Main Class).

 

Input and Output Format:

Refer sample input and output for formatting specifications.

Use array of objects to read wicket details and use String.split() function to display the wicket details.

All text in bold corresponds to input and the rest corresponds to output.

 

 

Sample Input and Output :

Enter the number of wickets

3

Enter the details of wicket 1

5,2,LBW,Gautam Gambir,Aswin

Enter the details of wicket 2

6,6,Bowled,Brad Hogg,Dwayne Bravo

Enter the details of wicket 3

7,3,Stumped,Robin Uthappa,Ravindra Jadeja

Wicket Details

Over : 5
Ball : 2

Wicket Type : LBW

Player Name : Gautam Gambir

Bowler Name : Aswin

Over : 6

Ball : 6

Wicket Type : Bowled

Player Name : Brad Hogg

Bowler Name : Dwayne Bravo

Over : 7

Ball : 3

Wicket Type : Stumped

Player Name : Robin Uthappa

Bowler Name : Ravindra Jadeja

 

 

Predefined Packages

1. java.lang.*  - Language Package - only one optional pkg

 

1. Object class

        - super class of all the classes (ie) any predefined or userdefined class by default inherit Object class

 

void add(int a) - int as arg

void add(String s)- String as arg

void add(Test t) - object of only Test class as arg

void add(Employee e) - object of only Employee class as arg

void add(Object o) - object of any class as arg

 

Constructor
	 - Object()

 

Methods

1. String toString() - String representation of an object

 

String s1=new String("Hello"); //all predefined class by default contains toString(), so if we print object of any predefined class it will print the content instead of object reference

sop(s1);   //Hello

 

Sample s2=new Sample("Hello");  //Userdefined

sop(s2);  //object reference

 

Whenever we print object of any class it will print only memory reference. But we dont print memory reference instead we want to print some content then in that case we have to override toString()

 

class A {

              String s1;

              A(String s){

                             s1=s;

              }

              @Override

              public String toString() {

                             return s1;

              }

             

}

public class Main {

              public static void main(String[] args) {

                  String a1=new String("Hello");

                  System.out.println(a1);   //Hello

                  A a2=new A("Hello");

                  //System.out.println(a2); //object reference

                  System.out.println(a2);  //automatically invokes toString() - Hello

                  System.out.println(a2.toString()); //Hello

              }

             

}

 

2. boolean equals(Object o) - used to check equality of the content

3. == (equals versus) - used to check equality of object reference

 

If we are not using new operator, then == also works like equals()

 

public class Main {

              public static void main(String[] args) {

           Integer a1=new Integer(42);

           Integer a2=new Integer(42);

           System.out.println(a1.equals(a2));  //true

                 System.out.println(a1==a2);  //false

                 String s1=new String("Hello");

                 String s2=new String("Hello");

    

                 System.out.println(s1.equals(s2));  //true

                 System.out.println(s1==s2);  //false

             ]

                 String s4="Hello";  //literal

                 String s5="Hello";  //literal

                 System.out.println(s4.equals(s5));  //true

                 System.out.println(s4==s5);  //true

              }            

}

 

4. int hashCode()

        - When we store some value into object, internally an address will be generated for that value, to return that address we use hashCode()

       - If two objects are equal according to equals(), then hashCode will return same

 

public class Main {

              public static void main(String[] args) {

                 String s1=new String("Hello");

                 String s2=new String("Hello");

                 System.out.println(s1.hashCode());

                 System.out.println(s2.hashCode());

              }            

}

 

5. protected void finalize()

 

Box b=new Box();  real object stored in heap

reference(stack)  

b=null;

 

Explicitly Garbage Collection

1. System.gc()

2. Runtime.gc()

 

finalize() used to perform cleanup activity before destroying the object. It is called by garbage collector before destroying the object from memory and invoked only once in the lifecycle of program

 

Unreferencinng the object

1. By anonymous object

       Anonymous object are those object which are created without reference variable

 

new Box().add();

 

2. By nulling reference

 

Box b=new Box();

b=null;

 

3. By assigning the reference to another variable

 

Box b1=new Box();  //1000

Box b2=new Box();  //2000

b1=b2;

sop(b1);  //2000

 

1. finalize() of which class is going to be called

 

public class Main {

              public static void main(String[] args) {

                String s1=new String("Hello");

                s1=null;

                System.gc();

                System.out.println("Garbage Collection is done");

              }            

              protected void finalize() {

                             System.out.println("Cleanup is done");

              }

}

 

public class Main {

              public static void main(String[] args) {

                Main s1=new Main();

                s1=null;

                System.gc();

                System.out.println("Garbage Collection is done");

              }            

              protected void finalize() {

                             System.out.println("Cleanup is done");

              }

}

 

2. Explicit call to finalize

 

public class Main {

              public static void main(String[] args) {

                Main s1=new Main();

                Main s2=new Main(); //2000

                s1=s2;

                s1.finalize();   //not destroy the object

                System.out.println("Garbage Collection is done");

                System.gc();

              }            

              protected void finalize() {

                            

                             System.out.println("Cleanup is done");

              }

}

 

 

6. final void wait()

7. final void wait(long msec)

8. final void notify()

9. final void notifyAll()

10. Object clone()

         - used to create exact copy of an object

         - clone() always follow shallow copy

         - If we want to take copy of an object using clone(), then that class should implements Cloneable interface which is a marker interface, in case if it is not implemented Cloneable interface then it will raise CloneNotSupportedException

        

Shallow copy

        - will have exact copy of all fields of original object (ie) any changes made to those object through clone object will be reflected in original object and vice versa

 

class Address {

              String city;

              String state;

              String country;

              public Address(String city, String state, String country) {

                             super();

                             this.city = city;

                             this.state = state;

                             this.country = country;

              }

}

class Employee implements Cloneable {

              int empid;

              String name;

              Address address;

              public Employee(int empid, String name, Address address) {

                             super();

                             this.empid = empid;

                             this.name = name;

                             this.address = address;

              }

             

              protected Object clone() throws CloneNotSupportedException {

                             return super.clone();

              }

}

public class Main {

              public static void main(String[] args) {

                  Address addr=new Address("Chennai","Tamilnadu","India");

                  Employee e1=new Employee(10,"Ram",addr);

                  Employee e2=null;

                  try {

                                           e2=(Employee)e1.clone();

                             } catch (CloneNotSupportedException e) {

                                           e.printStackTrace();

                             }

                  System.out.println(e1.address.state);  //Tamilnadu

                  e2.address.state="Kerela";

                  System.out.println(e1.address.state); //Kerela

              }

}

 

2. Wrapper class

       - classes that supports the primitive datatype, to perform any operation on datatype

       - All wrapper classes are immutable class(u cant change)

 

int a=10;

 

datatype   wrapper class

int   -   Integer

byte  -   Byte

short -   Short

long  -   Long

boolean - Boolean

char   -  Character

float  - Float

double - Double

 

1. Float class

       - used to perform operation on float datatype

 

Constructor

  1. Float(float f)

        Float f1=new Float(3.14f);

  2. Float(double d)

        Float f2=new Float(3.14);

  3. Float(String s) throws NumberFormatException

        Float f3=new Float("3.14");

        Float f4=new Float("1bc");  //NumberFormatException

 

int a=10, b=10; 

if(a==b)

 

float f1=3.14f,f2=3.14f;

if(f1==f2)  //error

 

Methods

1. static int compare(float f1,float f2) - compare 2 float datatype, if equal it return 0, if greater 1, if lesser -1

2. int compareTo(Float f) - compare 2 Float object , if equal it return 0, if greater 1, if lesser -1

3. static boolean isInfinite() - check float datatype is infinite or not

4. boolean isInfinite() - check Float object is infinite or not

5. static boolean isFinite() - check float datatype is finite or not

6. boolean isFinite() - check Float object is finite or not

7. static boolean isNaN() - check float datatype is nan or not

8. boolean isNaN() - check Float object is nan or not

9. static float parseFloat(String s) throws NFE  - convert String to related datatype

10. static Float valueOf(String s) throws NFE - convert String to Float object

11. float floatValue() - convert Float object to float datatype

12. int intValue()

13. double doubleValue()

14. short shortValue()

15. long longValue()

 

Constants

1. Float.MAX_VALUE

2. Float.MIN_VALUE

3. Float.POSITIVE_INFINITY

4. Float.NEGATIVE_INFINITY

5. Float.TYPE

 

public class Main {

              public static void main(String[] args) {

                 float f1=3.14f;

                 float f2=3.14f;

                 System.out.println(Float.compare(f1,f2));  //0

                

                 Float f3=new Float(3.14f);

                 Float f4=new Float(3.14f);

                 System.out.println(f3.compareTo(f4)); //0

                

                 float f5=(float)(1/0.);

                 System.out.println(Float.isInfinite(f5));  //true

                 Float f6=new Float(1/0.);

                 System.out.println(f6.isInfinite()); //true

                

                 float f7=(float)Math.sqrt(-4);

                 System.out.println(Float.isNaN(f7));  //true

                 Float f8=new Float(Math.sqrt(-4));

                 System.out.println(f8.isNaN()); //true

                

                 String s="3.14";

                 float f9=Float.parseFloat(s);

                 System.out.println(f9); //3.14

                 Float f10=Float.valueOf(s);

                 System.out.println(f10);  //3.14

                 float f11=f10.floatValue();

                 System.out.println(f11); //3.14

                 int i=f10.intValue();

                 System.out.println(i);  //3

                

                 System.out.println(Float.MAX_VALUE);

                 System.out.println(Float.MIN_VALUE);

                 System.out.println(Float.POSITIVE_INFINITY);

                 System.out.println(Float.NEGATIVE_INFINITY);

                 System.out.println(Float.TYPE);

              }

}

 

2. Double class

      - used to perform operation on double datatype

 

Constructor

   1. Double(double d)

   2. Double(String s) throws NFE


Handson

 

1. IPL Merchandise is an alternative form of revenue and brings substantial income.

 

Another merchandise company called “Fundas” has come up with a native flair offering customized mugs, team badges, helmets, etc. The company has decided to print a special code on the merchandises. The special code contains the captions of the IPL teams along with the jersey number of the celebrity players of the corresponding team on the merchandises. The code to be printed is considered valid for printing only if their:

--> first word is one of the team's caption [RCB, MI, CSK, SRH, KXIP, DD, KKR, RPSG and GL]

--> second word is the jersey number

Write a program that reads a string S corresponding to the team name and jersey number and validates if the name is eligible to be printed on the stocks.

Include a class UserMainCode with a static method called  validateTeam  which accepts a string and its return type is bool. In this method display the details as given in sample input and output.

Create a Class Main which would be used to accept  two Strings and call the static method called  validateTeam present in UserMainCode.

Input Format:

First line of the input is a string S, that corresponds to the team name and jersey number.

 

Output Format:

Output should display “Valid” if the team name and jersey number is valid for printing. Otherwise print “Invalid”.

 

Sample Input 1 :

CSK 7

Sample Output 1 :

Valid

 

Sample Input 2 :

RCB1 18

Sample Output 2 :

Invalid

 

2. In Cricket it is so common that the players are often called by their last names. Few cricketers have their origins from the same regions of the country which is why they have common last names. Sandeep is now entrusted with yet another task that is to check for the last names of players.

 

Given two player's names P1 and P2, Sandeep has to write a program to find if the last name of the two given players are the same. Help him do this using String Builder  method.

Include a class UserMainCode with a static method called display which accepts two strings and its return type is void. In this method display the details as given in sample input and output.

 

Create a Class Main which would be used to accepts two  Strings and call the static method called display present in UserMainCode.

Input Format:

First line of the input is a string P1, that corresponds to the first player's name.

Second line of the input is a string P2, that corresponds to the second player's name.

 

Output Format:

Output should print in a single line “Yes” if the last names of the players are the same. Otherwise print “No”.

 

Sample input

Mohit Sharma

Rohit Sharma

 

Sample output

Yes

 

 

Sample input

Mohit Sharma

Virat Kohli

 

Sample output

No

 

3. Write a program to read a string and find whether it is a valid string or not.

Validation Rules :

1. It accepts the player name as a string and is appended with the player's skill.

2.It ends with a symbol ,the symbol is '*' if the player is a raider and it is '#' if the player is a defender.

3.Player's first name,last name and skill should start with upper case letters

 

Include a class UserMainCode with a static method validatePlayer  which accepts a string. In this method check whether the given player name is valid as per the validation rules mentioned above. The return type is Boolean.

 

Create a Class Main which would be used to accept the string and call the static method present in UserMainCode.

 

Input and Output Format:

Input consists of a string.

Output consists of a string “Valid” or “Invalid”.

Refer sample output for formatting specifications.

 

Sample Input 1:

Anup Kumar-Raider*

Sample Output 1:

Valid

 

Sample Input 2:

Surender Nada-Defender#

Sample Output 2:

Valid

 

Sample Input 3:

Rohit Rana-Defender*

Sample Output 3:

Invalid

 

4. Write a program to read a string and find whether it is a valid string or not.

Validation Rules :

1. It accepts the player name as a string ,player name length should be between 4 to 20.

 

2..It starts with four digit number representing the player's debutant year.

 

3.It ends with single digit number representing the number of IPL season played by the player.

 

Include a class UserMainCode with a static method validatePlayer which accepts a string. In this method check whether the given player name is valid as per the validation rules mentioned above. The return type is Boolean.

 

 

Create a Class Main which would be used to accept the string and call the static method present in UserMainCode.

 

Input and Output Format:

Input consists of a string.

 

Output consists of a string “Valid” or “Invalid”.

Refer sample output for formatting specifications.

 

Sample Input 1:

 

2013Mohit Sharma3

 

Sample Output 1:

 

Valid

 

Sample Input 2:

 

200Mohammad Kaif

 

Sample Output 2:

 

Invalid

 

5. T20 IPL board get the number of player names and finds the players having the string “Sharma” in their name. Write a program to get the player names in an array and use Contains method to get the players whose name has the string "Sharma".

 

Input and Output Format:

Refer sample input and output for formatting specifications.

 

Sample Input/Output 1:

Enter number of players

5

Enter player names

Rohit Sharma

Adam Smith

Ishant Sharma

Mohit Sharma

Jaspirit Bumrah

Rohit Sharma

Ishant Sharma

Mohit Sharma

 

 

java.lang.* package

1. Object class

 

2. Wrapper class

- Float class

- Double class

 

-Integer,Short,Byte,Long wrapper class

Constructors

1. Integer(int i)

      Integer i=new Integer(20);

   Integer(String s) throws NFE

      Integer i=new Integer("20");

      Integer i1=new Integer("abc");

 

2. Short(short s)

     Short s1=new Short(23);   //error

     Short s2=new Short((short)23);  //correct

   Short(String s) throws NFE

     Short s3=new Short("23");

 

3. Byte(byte b)

     Byte b1=new Byte(12);  //error

     Byte b2=new Byte((byte)12);

   Byte(String s) throws NFE

     Byte b3=new Byte("12");

 

4. Long(long l)

     Long l1=new Long(14);   //correct

     Long l1=new Long(14l);  //correct

   Long(String s) throws NFE

     Long l1=new Long("14");

 

Methods

1. static int parseInt(String s)

2. static int parseInt(String s,int radix)

 

public class Main {

              public static void main(String[] args) {

                 String s="42";

                 int i=Integer.parseInt(s);

                 System.out.println(i);  //42

                 int j=Integer.parseInt(s,5);

                 //2*5^0=2

                 //4*5^1=20

                 System.out.println(j); //22

                 System.out.println(Integer.toBinaryString(2)); //10

                 System.out.println(Integer.toOctalString(9)); //11

                 System.out.println(Integer.toHexString(10)); //a

                 System.out.println(Integer.MAX_VALUE);

                 System.out.println(Integer.MIN_VALUE);

                 System.out.println(Integer.TYPE); //int

    }

}

 

5. Boolean class

       - used to perform operation on boolean datatype

 

Constructor

  1. Boolean(boolean b)

Boolean b1=new Boolean(true);

sop(b1);  //true

Boolean b2=new Boolean(false);

sop(b2); //false

Boolean b3=new Boolean(True);

sop(b3);  //error

Boolean b4=new Boolean(Helo);

sop(b4);  //error

  2. Boolean(String s) - we can give only true in any format it will return true, otherwise it returns false

Boolean b1=new Boolean("true");

sop(b1);  //true

Boolean b2=new Boolean("false");

sop(b2);  //false

Boolean b3=new Boolean("True");

sop(b3);  //true

Boolean b4=new Boolean("hello");

sop(b4);  //false

Boolean b5=new Boolean("TRUE");

sop(b5); //true

 

6. Character class

       - used to perform operation on char datatype

 

Constructor

  1. Character(char c)

 

Methods

1. static boolean isDigit(char c)

2. static boolean isLetter(char c)

3. static boolean isLetterOrDigit(char c)

4. static boolean isUpperCase(char c)

5. static boolean isLowerCase(char c)

6. static boolean isSpace(char c)

7. static char toUpperCase(char c)

8. static char toLowerCase(char c)

 

Autoboxing and Unboxing

     - Introduced from JDK1.5 onwards

     - Autoboxing is automatic conversion of primitive datatype to wrapper class

     - Unboxing is automatic conversion of wrapper class to datatype

 

With autoboxing                             Without autoboxing

Integer i;                                  Integer i;

int j;                                      int j;

i=25;  //Autoboxing                         i=new Integer(25);

j=i;   //Unboxing                           j=i.intValue();

 

3. String class

      - String is final class in java.lang.*

      - Fixed length of char, hence it is called immutable class (ie) we cant increase or decrease its size at runtime

 

Syntax: public class String extends Object implements Serializable, Cloneable, Comparable, CharSequence

 

Constructor

1. String()

2. String(String s)

3. String(byte[] b)

4. String(byte[] b, int start,int numofbytes)

5. String(char[] c)

6. String(char[] c, int start,int numofchars)

7. String(StringBuffer s)

 

Methods

1. String toString() - String representation of an object

2. char charAt(int pos) - return a single char

3. void getChars(int start,int end,char[] buf, int targetstart) - return a group of char

4. byte[] getBytes() - convert string to byte[]

5. char[] toCharArray() - convert String to char[]

6. boolean equals(String s) - check equality of content by taking case into consideration

7. boolean equalsIgnoreCase(String s) - check equality of content by without taking case into consideration

8. ==(equal versus) - check to equality of object reference

9. boolean startsWith(String s)

10. boolean endsWith(String s)

11. String toLowerCase()

12. String toUpperCase()

13. int compareTo(String s) - compare 2 strings taking case into consideration and do sorting, if two values are equal it returns 0, greater means +1, lesser means -1

14. int compareToIgnoreCase(String s) - compare 2 strings without taking case into consideration and do sorting, if two values are equal it returns 0, greater means +1, lesser means -1

15. String intern() - it stores string object info in string pool

 

String pool is a storage space in the Java heap memory where string literals are stored. It is also known as String Constant Pool or String Intern Pool. It is privately maintained by the Java String class. By default, the String pool is empty.

 

In stack memory, only the primitive data types like- int, char, byte, short, boolean, long, float and double are stored. Whereas, in the heap memory, non-primitive data types like strings are stored. A reference to this location is held by the stack memory.

 

The String Pool is empty by default, and it is maintained privately by the String class.

When we create a string literal, the JVM first checks that literal in the String Constant Pool. If the literal is already present in the pool, its reference is stored in the variable.

However, if the string literal is not found, the JVM creates a new string object in the String Constant Pool and returns its reference.

 

String s1="Hello";  //literal - string pool

String s2="Hello";

String s3="hi";

 

String s4=new String("Gello"); - stored in heap memory

String s5=new String("Gello"); - created new memory in heap

s4.intern();   s4 into string pool

 

16. int indexOf(char c)

    int indexOf(String s)

    int indexOf(int charval,int startindex)

    int indexOf(String s,int index)

       - used to return the position of first occurence of char in given string, if not found it returns -1

 

17. int lastIndexOf(char c)

    int lastIndexOf(String s)

    int lastIndexOf(String s,int index)

       - used to return the position of last occurence of char in given string, if not found it returns -1

18. String substring(int start) - return part of string from start position

19. String substring(int start,int end) - return part of string from start to end-1

20. int length()

21. String concat(String s) or + operator

22. String trim() - remove leading and trailing space

23. String replace(char old,char new)

24. String[] split(String delimiter)

    String[] split(String delimiter,int limit)

        - used to split the string based on delimiter

25. boolean matches(String regex) - match the string based on regex

26. boolean regionMatches(boolean ignorecase,int toffset,String search,int ooffset,int length) - used to match part of a string with another string

27. int codePointAt(int index)

28. int codePointBefore(int index)

29. int codePointCount(int beginindex, int endindex)

30. boolean contains(String s)

31. static String join(String delimiter,String...s) - used to join the string based on delimiter

32. static String copyValueOf(char[] c)

    static String copyValueOf(char[] c,int offset,int count)

33. static String format(String format,Object val)   

 

int a=13;

printf("%d",a);

 

%+-0wspecifier.precision

+ - add space before number

- - add space after number

0 - pad with zero

w - total width

specifier - d,f,x,o,s

precision - after decimal place

 

public class Main {

              public static void main(String[] args) {

                 byte[] b= {65,66,67,68,69};

                 String s1=new String(b);

                 System.out.println(s1); //ABCDE

                 String s2=new String(b,1,3);

                 System.out.println(s2); //BCD

                

                 char c[]= {'J','a','v','a'};

                 String s3=new String(c);

                 System.out.println(s3); //Java

                 String s4=new String(c,0,2);

                 System.out.println(s4); //Ja

                 String s5=new String(s4);

                 System.out.println(s5); //Ja

                

                 String s6="Hello";  //literal

                 System.out.println(s6.charAt(1));   //e

                

                 String s7="This is a demo of getchars method";

                 int start=10, end=14;

                 char buf[]=new char[end-start];  //4

                 s7.getChars(start, end, buf, 0);

                 System.out.println(buf); //demo

                

                 String s8="ABCD";

                 byte b1[]=s8.getBytes();

                 for(byte b2:b1)

                                System.out.println(b2); //65 66 67 68

                

                 char c1[]=s8.toCharArray();

                 for(char c2:c1)

                                System.out.println(c2);  //A B C D

                

                 String s9=new String("Hello");

                 String s10=new String("Hello");

                 String s11=new String("HELLO");

                 System.out.println(s9.equals(s10)); //true

                 System.out.println(s9.equals(s11));  //false

                 System.out.println(s9.equalsIgnoreCase(s11));  //true

                 System.out.println(s9==s10);  //false

                 String s12=s10;

                 System.out.println(s10==s12); //true

                 

                 String s13="Hello";

                 String s14="Hello";

                 System.out.println(s13==s14); //true

                

                 System.out.println("Foobar".startsWith("Foo"));  //true

                 System.out.println("Foobar".endsWith("bar"));  //true

                 System.out.println("Foobar".toLowerCase()); //foobar

                 System.out.println("Foobar".toUpperCase()); //FOOBAR

                 System.out.println("hello".compareTo("hello")); //0

                 System.out.println("cat".compareTo("hello")); //-5

                 System.out.println("hello".compareTo("cat")); //5

                 System.out.println("hell".compareTo("heck"));  //9

                

                 String s15="It is the time for all good men to come to their "

                                           + "country and pay their due tax";

                 System.out.println(s15.indexOf('t'));  //1

                 System.out.println(s15.indexOf("the")); //6
                 System.out.println(s15.indexOf("THE")); //-1

                 System.out.println(s15.indexOf(" ")); //2

                 System.out.println(s15.indexOf(116,7)); //10

                 System.out.println(s15.indexOf("the",10)); //43

                 System.out.println(s15.lastIndexOf('t'));  //75

                 System.out.println(s15.lastIndexOf("the")); //65

                 System.out.println(s15.lastIndexOf("the",65)); //43

                

                 String s16="Helloworld";

                 System.out.println(s16.substring(6)); //orld

                 System.out.println(s16.substring(2,6)); //llow - start to end-1

                

                 String s17="Hello";

                 System.out.println(s17.length());  //5

                 System.out.println(s17.concat("world"));  //Helloworld

                 System.out.println(s17.length());  //5

                 String s18=s17.concat("world");

                 System.out.println(s17); //Hello

                 System.out.println(s18); //Helloworld

                

                 String s19=" Hello world ";

                 System.out.println(s19.length()); //13

                 System.out.println(s19.trim());  //Hello world

                 System.out.println(s19.length());  //13

                 String s20=s19.trim();

                 System.out.println(s20.length());  //11

                

                 System.out.println("Hello".replace('e', 'i'));  //Hillo

                

                 String s21="one-two-three";

                 String t1[]=s21.split("-");

                 for(String t:t1)

                                System.out.println(t);  //one   two   three

                

                 String s22="one.two.three";

                 String t2[]=s22.split([file://.]\\.);

                 for(String t:t2)

                                System.out.println(t);  //one    two    three

                

                 String s23="A*bunch*of*stars";

                 String t3[]=s23.split("\\*");

                 for(String t:t3)

                                System.out.println(t);  //A    bunch    of    stars

                

                 String s24="A*bunch*of*stars";

                 String t4[]=s24.split("\\*",3);

                 for(String t:t4)

                                System.out.println(t);  //A    bunch    of*stars

                

                 String s25="string is a class";

                 String t5[]=s25.split("s");

                 for(String t:t5)

                                System.out.println(t);  //tring i

                                             // a cla

                

                 String s26="No concession, no concillation, no compromise and just give and take policy";

                 String t6[]=s26.split("concession|concillation|compromise|(give and take)");

                 for(String t:t6)

                                System.out.println(t);  //No

                                             //, no

                                             //, no

                                             //and just

                                             //policy

                

                String s27="Welcome to Java";

                System.out.println(s27.matches("(.*) to PHP")); //false

                System.out.println(s27.matches("Welcome to (.*)")); //true

                System.out.println(s27.matches("Java"));  //false

                System.out.println(s27.matches("(.*) to (.*)")); //true

               

                String s28="ABC Windows test"; //Windows test

                System.out.println(s28.regionMatches( 4, "windows", 0, 7));  //false

                System.out.println(s28.regionMatches(true,4, "windows", 0, 7)); //true

               

                System.out.println("abcd".codePointAt(0)); //97

                System.out.println("abcd".codePointBefore(2)); //98

                System.out.println("abcdefg".codePointCount(0, 5));  //5

              // System.out.println("abcdefg".codePointCount(0, 9));  //exception

                System.out.println("Hello".contains("e"));  //true

                System.out.println("Hello".contains("E"));  //false

               

                System.out.println(String.join("-", "one","two","three")); //one-two-three

               

                char c2[]= {'a','b','c','d','e','f','g'};

                String s29="";

                System.out.println(s29.copyValueOf(c2)); //abcdefg

                System.out.println(s29.copyValueOf(c2, 3, 2)); //de

               

                int a=35;

                System.out.println(a);  //35

                System.out.println(String.format("%d", a)); //35

                System.out.println(String.format("|%d|", a)); //|35|

                System.out.println(String.format("|%5d|", a)); //5- total width |   35|

                System.out.println(String.format("|%-5d|", a)); //|35   |

                System.out.println(String.format("|%06d|", a));  //|000035|

                //System.out.println(String.format("|%-06d|", a)); //exception

                System.out.println(String.format("|%f|", 123.456)); //|123.456000|

                System.out.println(String.format("|%.2f|", 123.456)); //|123.46|

                System.out.println(String.format("|%8.2f|", 123.456)); //|   123.46|

    }

}

 

4. StringBuffer class

       - present in java.lang.*

       - It is a mutable class, variable length of char (ie) we can increase or decrease its size at runtime

       - By default StringBuffer is synchronzied or thread safe, it always gives lower performance

       - Default capacity of StringBuffer is 16

       - We cant override equals() in StringBuffer, using toString() we convert StringBuffer to String class and then we apply equals() - it returns false

 

Constructors

1. StringBuffer()

2. StringBuffer(String s)

3. StringBuffer(int capacity)

 

Methods

1. int length()

2. char charAt(int pos)

3. void setCharAt(int index,char c)

4. void setLength(int length)

5. int capacity()

6. StringBuffer append(int i)

   StringBuffer append(char c)

   StringBuffer append(String s)

         - add at the end of Stringbuffer

7. StringBuffer insert(int index,int i)

   StringBuffer insert(int index,char i)

   StringBuffer insert(int index,String i)

      - insert anywhere in StringBuffer

8. StringBuffer reverse()

9. StringBuffer replace(int start,int end, String s)  //start to end-1

10. StringBuffer delete(int start,int end) - delete group of char

11. StringBuffer deleteCharAt(int index) - delete single char

 

public class Main {

              public static void main(String[] args) {

                 StringBuffer sb1=new StringBuffer("Hello");

                 System.out.println(sb1);  //Hello

                 System.out.println(sb1.length()); //5

                 System.out.println(sb1.capacity());  //21 = 16+5

                 System.out.println(sb1.charAt(1));  //e

                 sb1.setCharAt(1, 'i');

                 System.out.println(sb1);  //Hillo

                 sb1.setLength(2);

                 System.out.println(sb1); //Hi

                 System.out.println(sb1.length()); //2

                

                 int b=10;

                 StringBuffer sb2=new StringBuffer();

                 String s=sb2.append("a=").append(b).append("!").toString();

                 System.out.println(s); //a=10!

                

                 StringBuffer sb3=new StringBuffer("I Java");

                 System.out.println(sb3.insert(2, "like ")); //I like Java

                

                 StringBuffer sb4=new StringBuffer("Hello");

                 System.out.println(sb4.reverse());  //olleH

                

                 StringBuffer sb5=new StringBuffer("This is a test");

                 System.out.println(sb5.replace(5, 7, "was")); //This was a test

                

                 StringBuffer sb6=new StringBuffer("This is a test");

                 System.out.println(sb6.delete(5, 7));  //This a test

                 System.out.println(sb6.deleteCharAt(0));  //his a test

    }

}

 

5. StringBuilder class

         - Available from JDK1.5 onwards

         - It is similar to StringBuffer but it is not synchronized or threadsafe so it gives better performance

Handson

 

1. Exception 2(ArrayIndexOutOfBoundsException And NegativeArraySizeException)

 

Write a program to get the number of overs and the runs scored in each over. Get the over number from the user and display number of runs scored in that over. Let

•            number of overs be the array size

•            over number be the index of the array+1

•            runs be the array elements

 

This program may generate

1. NegativeArraySize Exception when the number of overs is negative

2. ArrayIndexOutOfRange Exception when the over number that is searched is beyond the specified over numbers.

 

Use exception handling mechanisms to handle these exceptions.Use a single catch block. In the catch block, print the class name of the exception thrown.

Input and Output Format:

Refer sample input and output for formatting specifications.

All text in bold corresponds to input and the rest corresponds to output.

 

Sample  Input/Output 1:

Enter the number of overs

3

Enter the number of runs for each over

8

15

12

Enter the over number

2

Runs scored in this over : 15

 

Sample  Input/Output 2:

Enter the number of overs

3

Enter the number of runs for each over

8

15

12

Enter the over number

4

java.lang.ArrayIndexOutOfBoundsException

 

Sample  Input/Output 3:

Enter the number of overs

-1

Enter the number of runs for each over

java.lang.NegativeArraySizeException

 

 

2.Custom Exceptions [Age]

 

Write a program to get the name and age of the player from the user and  display it.

player name is a string

player age is an integer value

Note : The player is eligible to participate in IPL when their age is 19 and above

  

This program may generate  

1. InvalidAgeRange Custom Exception when the player's age is below 19

 Use exception handling mechanisms to handle these exceptions

 

Create a class called CustomException which extends Exception and it includes constructor to initialize the message.

 

 Use appropriate exception handling mechanisms to handle these exceptions 

 

Input and Output Format:

Refer sample input and output for formatting specifications.

All text in bold corresponds to input and the rest corresponds to output.

 

Sample  Input/Output 1:

Enter the player name

Albie Morkel

Enter the player age

35

Player name : Albie Morkel

Player age : 35

 

Sample  Input/Output 2:

Enter the player name

Ishan Kishan

Enter the player age

16

CustomException: InvalidAgeRangeException

 

 

3. TeamNameNotFound Exception

 

Write a program to get the two team names i.e expected Runner and Winner team of IPL season 4 and display it.

Team name is a string

 

Note : The team name given below are only eligible to take part in IPL season 4

Chennai Super Kings

Deccan Chargers

Delhi Daredevils

Kings XI Punjab

Kolkata Knight Riders

Mumbai Indians

Rajasthan Royals

Royal Challengers Bangalore

This program may generate TeamNameNotFound Custom Exception when the expected team entered is not present in the above eligible teams list for IPL season 4.

Use exception handling mechanisms to handle these exceptions

 

Input and Output Format:

Refer sample input and output for formatting specifications.

All text in bold corresponds to input and the rest corresponds to output.

Sample Input and Output 1:

Enter the expected winner team of IPL Season 4

Chennai Super Kings

Enter the expected runner Team of IPL Season 4

Mumbai Indians

Expected IPL Season 4 winner: Chennai Super Kings

Expected IPL Season 4 runner: Mumbai Indians

 

Sample Input and Output 1:

Enter the expected winner team of IPL Season 4

Pune Warriors

TeamNameNotFoundException: Entered team is not a part of IPL Season 4

 

 

java.lang.*

1. Object

2. Wrapper class

3. String

4. StringBuffer

5. StringBuilder

 

       Java (2 concept)    

Error - generated at compile time - syntacial/human made error

Exception - generated at runtime - logical error, eg: Divide by 0, file not found

 

6. Throwable class

        - used to handle exception handling in Java

 

2 types of Exception

1. Checked Exception

       - all subclasses of Exception class excluding RuntimeException. Eventhough we have written 100% correct prg also, ur code has to be surrounded by try/catch block or throws keyword otherwise ur prg will not compile

      - Will insist the programmer to surround the code using  try/catch block or throws keyword otherwise ur prg will not compile

 

2. Unchecked Exception

       - all subclasses of RuntimeException class

       - Eventhough ur prg contains an exception,the compiler will just compile the program but at runtime we get related exception

       -  Will not insist the programmer to surround the code using  try/catch block or throws keyword, the prg will compile but at runtime we get related exception

 

Constructors

  1. Throwable()

  2. Throwable(String msg)

  3. Throwable(String msg,Throwable t)

 

Types of Exception

1. ArthimeticException - divide anything by 0z

2. ArrayIndexOutOfBoundsException - only for datatype array

      int a[]=new int[3];

        a[4]=1;

3. StringIndexOutOfBoundsException - only for string array

      String a[]=new String[3];

        a[4]="1";

4. NegativeArraySizeException

int a[]=new int[-3];

5. NumberFormatException

     int a=Integer.parseInt("abc");

6. ArrayStoreException

int a[]=new int[3];

   a[0]="one";

7. NullPointerException

class A{

   void show(){  

   }

}

class Main {PSVM {

   A a=new A();

   a.show();

   a=null;

   a.show();

8. ClassCastException

class A{

}

class B extends A {}

   

A a=new A();

B b=new B();

  a=b;  //correct

  b=a;  //Exception

 

5 keywords

1. try

     - Program to be monitored for exception has to be put inside try block

2. catch

     - used to catch the exception generated, mainly used to print user defined messages when an exception occurs

3. finally

     - optional stmt, it will be executed everytime irrespective of exception occurs or not

     - used  for closing the resource or cleaning the memory

     - used in 3 cases - file, database, socket programming

try {

fp=fopen("a.txt","r");

read operation

}

catch(Exception e) {

}

finally {

   fclose(fp);

}

 

3 ways

1. try{                         2. try{                    3. try{

}                              }                             }                catch(Exception e){             catch(Exception e){           finally {

}                               }                             }

finally{

}

 

- We should not write anything between trycatch and finally

 

To get input from user

1. Using Scanner/BufferedReader

2. Directly define in prg itself

3. Using CommandLine argument

      - We give input while running the prg in command line

      - When we use args argument inside the prg, then for that prg we have to give input through command line

      - Each command line should be separated by space

 

 

public class Main {

              public static void main(String[] args) {

                 for(int i=0;i<args.length;i++) {

                                System.out.println(args[i]);

                 }

    }

}

 

Rigth Click - Run as - Run configuration - Goto Arguments tab - Under Program Arguments we have to give input separated with space

 

public class Main {

              public static void main(String[] args) {

                 try {

                    int a=Integer.parseInt(args[0]);

                    int c=10/a;

                    System.out.println(c);

                 }

                 catch(ArithmeticException e) {

                                System.out.println("Divide by 0 "+e);

                 }

    }

}

 

Multi catch statement

     - single try can contain multiple catch blocks

 

public class Main {

              public static void main(String[] args) {

                 try {

                    int a=Integer.parseInt(args[0]);

                    int c=10/a;

                    System.out.println(c);

                    int b[]= {23};

                    b[50]=100;

                 }

                 catch(ArithmeticException e) {

                                System.out.println("Divide by 0 "+e);

                 }

                 catch(ArrayIndexOutOfBoundsException e) {

                                System.out.println("Array Index: "+e);

                 }

                

    }

}

 

- Whenever we define general class called Exception or Throwable, it should be always present in last catch block otherwise it leads to compilation error

 

public class Main {

              public static void main(String[] args) {

                 try {

                    int a=Integer.parseInt(args[0]);

                    int c=10/a;

                    System.out.println(c);

                    int b[]= {23};

                    b[50]=100;

                 }

                 /*catch(/*Exception e*/ Throwable e) {

                                System.out.println(e);

                 }*/    //Compilation error

                 catch(ArithmeticException e) {

                                System.out.println("Divide by 0 "+e);

                 }

                 catch(ArrayIndexOutOfBoundsException e) {

                                System.out.println("Array Index: "+e);

                 }

                 catch(NumberFormatException e) {

                                System.out.println(e);

                 }

                 catch(NullPointerException e) {

                                System.out.println(e);

                 }

                 catch(/*Exception e*/ Throwable e) {

                                System.out.println(e);

                 }

             

                 

    }

}

 

- From JDK1.7 version, we define multiple exception in a single catch block using  |

 

public class Main {

              public static void main(String[] args) {

                 try {

                    int a=Integer.parseInt(args[0]);

                    int c=10/a;

                    System.out.println(c);

                    int b[]= {23};

                    b[50]=100;

                 }

                               

                 catch(ArithmeticException|ArrayIndexOutOfBoundsException

                                              |NumberFormatException|NullPointerException e) {

                                System.out.println(e);

                 }

       catch(Exception e) {

                 System.out.println(e);

       }

                

    }

}

 

4. throw keyword

       - used to manually throw an exception

       - whenever it invokes throw keyword, it will automatically goes to related catch block

 

Syntax: throw new Exception(String msg);

 

public class Main {

              static void demo() {

                             try {

                                throw new NullPointerException("Hello");

                             }

                             catch(NullPointerException e) {

                                           System.out.println("Caught");

                                           throw e;

                             }

              }

              public static void main(String[] args) {

                             try {

                   demo();

                             }

                             catch(NullPointerException e) {

                                           System.out.println("Recaught");

                             }

    }

}

 

5. throws keyword

       - throws keyword is used to declare an exception, and used only in methods

       - Used to indicate that the method might throw one of the exception

 

public class Main {

              static void demo() throws NullPointerException {

                                throw new NullPointerException("Hello");

              }

              public static void main(String[] args) {

                             try {

                   demo();

                             }

                             catch(NullPointerException e) {

                                           System.out.println("Recaught");

                             }

    }

}

 

 

public class Main {

              static void demoA() {

                             try {

                                           System.out.println("Inside demoA");

                                           throw new RuntimeException();

                             }

                             /*catch(RuntimeException e) {

                                           System.out.println("Exception caught inside demoA");

                             }*/

                             finally {

                                           System.out.println("demoA finally");

                             }

              }

              static void demoB() {

                             try {

                                           System.out.println("Inside demoB");

                                           return;

                             }

                             finally {

                                           System.out.println("demoB Finally");

                             }

              }

              public static void main(String[] args) {

                             try {

                                demoA();

                             }

                             catch(RuntimeException e) {

                                           System.out.println("Exception caught");

                             }

                             demoB();

    }

}

 

User defined Exceptions

    - Your userdefined exception class should extend Exception class and override toString()

 

class A extends Exception {

}

 

class NotValidAgeException extends Exception{

              String s1="";

             

              public NotValidAgeException(String s1) {

                             this.s1=s1;

              }

 

              @Override

              public String toString() {

                             return s1;

              }

 

}

public class Main {

              static void validateAge() throws NotValidAgeException {

                             Scanner sc=new Scanner(System.in);

                             System.out.println("Enter age");             

                             int age=sc.nextInt();

                             if(age<18) {

                                           throw new NotValidAgeException("Your age is not eligible");

                             }

                             else {

                                           System.out.println("Your age is eligible");

                             }

              }

              public static void main(String[] args) {

                   try {

                             validateAge();

                   }

                   catch(NotValidAgeException e) {

                             System.out.println(e);

                   }

                  

    }

}

 

Assertions

    - Available from JDK1.5 onwards

    - used to check boolean conditions at runtime

Syntax: assert <<expression>>;

        assert <<expression>>:String message;

    - By default assertion is disabled in Java, while running we have to enable the assertion using -ea options

    - Provided with assert keyword, AssertionError class is unchecked exceptio n because it is inherited from Error class

    - If assert condition fails then it will throw AssertionError class

public class Main {

              static double withdraw(double balance, double amount) {

                             assert (balance>=amount);  //Java will just ignore this line

                             return (balance-amount);

              }

              public static void main(String[] args) {

                   System.out.println(withdraw(1000,500));  //500.0

                   System.out.println(withdraw(1000,2000)); //-1000.0

    }

}   

 

public class Main {

              static double withdraw(double balance, double amount) {

                             assert (balance>=amount); 

                             return (balance-amount);

              }

              public static void main(String[] args) {

                   System.out.println(withdraw(1000,500));  //500.0

                   System.out.println(withdraw(1000,2000)); //throws AssertionError class

    }

}   

 

 

public class Main {

              static double withdraw(double balance, double amount) {

                             assert (balance>=amount):"Balance is insufficient"; 

                             return (balance-amount);

              }

              public static void main(String[] args) {

                   System.out.println(withdraw(1000,500));  //500.0

                   System.out.println(withdraw(1000,2000)); //-1000.0

    }

}

 

try with resources

    - Available from JDK1.7 onwards

    - Used to close the resources automatically at the end of stmt, using AutoCloseable interface

 

Syntax:

   try(resources) {

 

   }

   catch(Exception e){

   }

 

public class Main {

              public static void main(String[] args) {

                             String line="";

                   try(BufferedReader br=new BufferedReader(new FileReader("C:\\Spring\\JavaExample\\src\\com\\pack\\Main.java"));

                             PrintWriter pw=new PrintWriter(new File("a.txt"));){

                             while((line=br.readLine())!=null) {

                                            System.out.println(line);

                             }           

                   }

                   catch(Exception e) {

                             System.out.println(e);

                   }

    }

}

 

From JDK1.9 onwards, enhancement in try with resources, we can define the resources outside the try block and we can use it

 

public class Main {

              public static void main(String[] args) throws Exception {

                             String line="";

                             BufferedReader br=new BufferedReader(new FileReader("C:\\Spring\\JavaExample\\src\\com\\pack\\Main.java"));

               PrintWriter pw=new PrintWriter(new File("a.txt"));

                   try(br;pw){

                             while((line=br.readLine())!=null) {

                                            System.out.println(line);

                             }           

                   }

                   catch(Exception e) {

                             System.out.println(e);

                   }

    }

}

 

Exception handling in method overriding

1. If superclass method does not declare an exception , then subclass overridden method cannot declare the checked exception but it can declare unchecked exception

 

class A {

              void add() {

                            

              }

}

class B extends A  {

              void add() throws ArithmeticException {  //correct

                            

              }

}

 

class A {

              void add() {

                            

              }

}

class B extends A  {

              void add() throws IOException { //error

                            

              }

}

 

2. If superclass method declares an exception , then subclass overridden method can declare the same exception,subclass exception or no exception  but it cannot declare parent exception

 

class A {

              void add() throws Exception {

                            

              }

}

class B extends A  {

              void add() throws Exception {  //correct

                            

              }

}

 

class A {

              void add() throws Exception {

                            

              }

}

class B extends A  {

              void add() {   //correct

                            

              }

}

 

class A {

              void add() throws ArithmeticException {

                            

              }

}

class B extends A  {

              void add() throws Exception {  //error

                            

              }

}

 

class A {

              void add() throws Exception {

                            

              }

}

class B extends A  {

              void add() throws ArithmeticException {  //correct

                            

              }

}

Handson

 

1. The Chennai Super Kings were the most successful team in the IPL with a win percentage of 60.68 and had won the title twice in succession (2010 and 2011).

 

The CSKs have played “n” matches so far in IPLs. Given the number of matches “n” that CSK has played and their team score in the matches as a list, write a program to find the total runs and the average runs scored by the team in all “n” matches.

 

Input Format:

First line of the input is an integer “n” that corresponds to the number of matches played by CSK.

Next “n” lines contains an integer in each line, that corresponds to the runs scored by CSK in each of the “n” matches.

 

Output Format:

Output should print in the first line the integer that gives the total runs scored by CSK in the matches.

In the second line, print a float value that gives the average runs.

 

Sample Input :

5

200

210

180

176

192

 

Sample Output :

958

191.6

 

 

2.  A measure of a batsman's greatness is his ability to score runs on foreign conditions. It is quite obvious in Cricket that most batsmen have been excellent at home grounds but flops overseas. Consequently not many teams have aggregates balanced in terms of home and away performances.

 

Sunil now wanted to analyze the performance of IPL teams based on the runs scored in home as well away matches. Given are the team name, number of matches played by the team in home ground “n” and away grounds “m” respectively, runs scored by the team in each of the matches both home and away respectively. Write a program to store the runs scored by the team in both home ground and in other grounds in a list and help Sunil to display the score (in both home and away grounds) of the team that is greater than 300.

 

Input Format:

 

First line of the input contains a string that gives the name of the IPL team.

 

Second line of input contains the integer “n” that corresponds to the number of matches played by the team in home grounds.

 

Next “n” lines contains the runs scored by the team in each of the matches in home grounds.

 

Next line that follows contains the integer “m” that corresponds to the number of matches played by the team in away grounds.

 

Next “m” lines contains the runs scored by the team in each of the matches in away grounds.

 

Output Format:

 

Output should display the runs scored by the team in both home ground and in other grounds as a list, line after line.

 

In the lines to follow, the output should display the score (in both home and away grounds) of the team that is greater than 300, line after line.

 

Sample Input and output :

 

Enter the team name

Chennai Super Kings

Enter the number of matches played in home ground

2

Enter the runs scored

290

320

Enter the number of matches played in other ground

3

Enter the runs scored

399

180

150

Runs scored by Chennai Super Kings

290

320

399

180

150

Run scored by Chennai Super Kings more than 300

320

399

 

 

java.util.*

    - Utility framework or collection framework

    - used to store collection of objects - any objects (ie) Employee, Student, String, Player, Venue

 

1. Collection interface - core interface in order to store collection of object

2. Collections class - provided with static methods or static algorithm that supports util package

 

Collection interface

      - core interface in order to store collection of object

 

Methods

1. boolean add(Object o) - add single object

2. boolean addAll(Collection c) - add multiple object

3. boolean remove(Object o) - remove single object

4. boolean removeAll(Collection c) - remove multiple object

5. boolean contains(Object o) - check single object present in Collection or not

6. boolean containsAll(Collection c) - check multiple object present in Collection or not

7. boolean retainAll(Collection c)- remove from the target collection all the elemts that are not contained in the specified collection

8. int size() - return number of objects present in the collection

9. boolean isEmpty() - to check collection is empty or not

10. Object[] toArray() - return a array containing all elts in collection

11. String toString()

12. boolean equals(Object o)

13. Iterator iterator()

14. ListIterator listIterator()

 

List interface

    - Ordered and duplicate elements allowed

 

Methods

1. void add(int index,Object o) - add single object at particular index position

2. boolean addAll(int index,Collection c) - add multiple object at particular index position

3. Object get(int index) - return single object present at particular index position

4. int indexOf(Object o) - return position of first occurence of object in given collection

5. int lastIndexOf(Object o) - return position of last occurence of object in given collection

6. Object remove(int index) - remove single object present at particular index position

7. Object set(int index,Object val) - replace an object at particular index

8. List subList(int start,int end) - return part of list from start to end-1

 

Set interface

     - unordered and no duplicate elets allowed

 

SortedSet interface

     - sort the elts of Set interface

 

Methods

1. Object first() - return first elt

2. Object last() - return last elt

3. SortedSet subSet(Object from, Object end) - return part of set from start to end-1

4. SortedSet headSet(Object elt) - return all elts present before specified elt

    (1 2 3 4 5).headSet(3)  //1 2

 

5. SortedSet tailSet(Object elt) - return all elts present after specified elt

    (1 2 3 4 5).tailSet(3)  //4 5

 

List interface

     - Ordered and duplicate elements allowed

 

int a[]=new int[3];   - Static array

 

1. ArrayList class

        - It is similar to array but it is called as dynamic array (ie) we can increase or decrease its size at runtime

 

Syntax: public class ArrayList extends AbstractList implements List, Cloneable, Serializable, RandomAccess

 

        - used for faster retrieval of data and slower in insertion and deletion

        - default capacity is 10

 

Constructor

   1. ArrayList()

   2. ArrayList(int capacity)

   3. ArrayList(Collection c)

 

public class Main {

              public static void main(String...args) {

                  ArrayList l1=new ArrayList();

                  System.out.println(l1.size());  //0

                  l1.add("A");

                  l1.add("B");

                  l1.add(10);   //Autoboxing

                  System.out.println(l1.size());  //3

                  //wheneever we print object of any collection inside []

                  System.out.println(l1); //[A,B,10]

                 

                  ArrayList l2=new ArrayList();

                  System.out.println(l2.size()); //0

                  l2.addAll(l1);

                  System.out.println(l2); //[A,B,10]

                 

                  System.out.println(l1.contains(10));  //true

                  System.out.println(l1.containsAll(l2)); //true

                  System.out.println(l1.indexOf(10)); //2

                 

                  List l3=new ArrayList();  //DMD

                  l3.add("A");

                  l3.add("B");

                  l3.add(1);

                  l3.add(2);

                  l3.add(3);

                  System.out.println(l3);  //[A,B,1,2,3]

                 

                  List l4=new ArrayList();

                  l4.add("A");

                  l4.add("B");

                  l4.add(1);

                  System.out.println(l4); //[A,B,1]

                 

                  l3.retainAll(l4);

                  System.out.println(l3); //[A,B,1]

              }

}

 

Generics

    - Available from JDK1.5 onwards

    - used to specify what type of object stored in the collection, avoid type casting

    - denoted by <>

 

List<String> l1=new ArrayList<String>();  //JDK1.5

List<Integer> l2=new ArrayList<>(); //From JDK1.7

 

public class Main {

              public static void main(String...args) {

                List<String> l1=new ArrayList<>();

                System.out.println(l1.size());  //0

                l1.add("C");

                l1.add("F");

                l1.add(1,"O");

                l1.add("T");

                l1.add("R");

                //C,O,F,T,R

                System.out.println(l1); //[C,O,F,T,R]

                System.out.println(l1.get(2));  //F

                System.out.println(l1.contains("S"));  //false

                List<String> l2=new ArrayList<>();

                l2.add("C");

                l2.add("F");

                System.out.println(l1.containsAll(l2)); //true

                System.out.println(l1.indexOf("T")); //3

                l1.remove("T");  //[C,O,F,R]

                l1.remove(1);

                System.out.println(l1); //[C,F,R]

               

              }

}

 

2. LinkedList class

       - It is also called dynamic array

       - used for faster insertion and deletion, slower in selection

 

Syntax: public class LinkedList extends AbstractSequentialList implements List, Cloneable, Serailizable, Deque

 

Deque - Double Ended Queue - do insertion and deletion at both ends

 

Constructors

    1. LinkedList()

    2. LinkedList(Collection c)

   

Methods

1. void addFirst()

2. void addLast()

3. Object getFirst()

4. Object getLast()

5. Object removeFirst()

6. Object removeLast()

7. void push(Object o)

8. Object pop()

9. boolean offerFirst(Object o) - insert specified elt front of the list

10. boolean offerLast(Object o) - insert specified elt last of the list

11. Object peekFirst() - retrieves first elt of the list but does not remove

12. Object peekLast() - retrieves last elt of the list but does not remove

13. Object pollFirst() - retrieves first elt of the list and remove

14. Object pollLast() - retrieves last elt of the list and remove

 

public class Main {

              public static void main(String...args) {

                LinkedList<Integer> l1=new LinkedList<>();

                l1.add(3);

                l1.add(5);

                l1.add(2);

                l1.add(1,7);

                l1.addFirst(8);

                l1.addLast(9);

                System.out.println(l1.size()); //6 

                System.out.println(l1); //[8,3,7,5,2,9]

                System.out.println(l1.get(5)); //9

                System.out.println(l1.getFirst()); //8
                System.out.println(l1.getLast()); //9

                l1.remove(1); //8,7,5,2,9

                l1.removeFirst(); //7,5,2,9

                l1.removeLast();

                System.out.println(l1); //[7,5,2]

                System.out.println(l1.peekFirst()); //7

                System.out.println(l1.pollLast()); //2

                System.out.println(l1); //[7,5]

              }

}

 

3. Vector class

      - It is a legacy(older) class

      - It is also called dynamic array, but it is synchronized or threadsafe

      - Default capacity is 10

 

Syntax: public class Vector extends AbstractList implements List,Cloneable, Serailizable

 

Constructor

   1. Vector()

   2. Vector(int capacity)

   3. Vector(int capacity,int increment)

   4. Vector(Collection c)

 

public class Main {

              public static void main(String...args) {

                  Vector<Integer> v=new Vector<>(3,2);

                  System.out.println(v.size()); //0

                  System.out.println(v.capacity()); //3

                  v.add(1);

                  v.add(2);

                  v.add(3);

                  v.add(4);

                  System.out.println(v.size()); //4

                  System.out.println(v.capacity()); //5

                  v.add(5);

                  v.add(6); //5+2

                  System.out.println(v.size()); //6

                  System.out.println(v.capacity()); //7

                  System.out.println(v); //[1,2,3,4,5,6]

              }

}

 

Set interface

    - unordered and no duplicates allowed

 

1. HashSet class

      - does not maintain any insertion order and the elts are inserted in the basis of their hashcode value

      - default capacity is 16

 

Syntax: public class HashSet extends AbstractSet implements Set, Cloneable, Serializable

 

Constructor

   1. HashSet()

   2. HashSet(int capacity)

   3. HashSet(int capacity,float fillratio)

       fillratio ranges from 0.0 to 1.0 - default is 0.75

   4. HashSet(Collection c)

 

Set<Integer> hs=new HashSet<>();       Map<Integer,Object> hm=new HashMap<>();

sop(hs.size()); //0

hs.add(2);                             hm.put(2,PRESENT);

hs.add(3);                             hm.put(3,PRESENT);

hs.add(2);                             hm.put(2,PRESENT);

sop(hs.size());  //2

sop(hs); //[2,3]

 

When we create HashSet, it internally creates HashMap(unique key value pair), with key as what elt we are inserting into the hashset and value as dummy object called PRESENT

 

If hm.put(key,value) returns null then the statement hm.put(2,PRESENT)==null will return true then the element will be added into hashset

 

If hm.put(key,value) returns old value of key then the statement hm.put(2,PRESENT)==null will return false then the element will not be added into hashset

 

Set<Integer> hs=new HashSet<>(3);

hs.add(1);

hs.add(2);

hs.add(3);

hs.add(4);  3*0.75=2.25+3=5.25

hs.add(5);

hs.add(6); 5.25*0.75=3+5.25=8.25

 

2. LinkedHashSet class

        - used to maintain the insertion order of the set

 

Syntax: public class LinkedHashSet extends HashSet implements Set,Cloneable, Serializable

 

Constructor

   1. LinkedHashSet()

   2. LinkedHashSet(int capacity)

   3. LinkedHashSet(int capacity,float fillratio)

       fillratio ranges from 0.0 to 1.0 - default is 0.75

   4. LinkedHashSet(Collection c)

 

3. TreeSet class

       - Print the elements of Set interface in Sorted format(ie)numbers in ascending, string in alphabetical order

 

Syntax: public class TreeSet extends AbstractSet implements NavigableSet, Cloneable, Serializable

 

Constructor

   1. TreeSet()

   2. TreeSet(Comparator c)

   3. TreeSet(Collection s)

   4. TreeSet(SortedSet s)

 

public class Main {

              public static void main(String...args) {

          Set<Integer> hs=new HashSet<>();

           hs.add(20);

           hs.add(3);

           hs.add(11);

           hs.add(4);

           hs.add(1);

           System.out.println(hs); //random order

          

           LinkedHashSet<Integer> ls=new LinkedHashSet<>();

           ls.add(20);

           ls.add(3);

           ls.add(11);

           ls.add(4);

           ls.add(1);

           System.out.println(hs); //[20,3,11,4,1]

          

           TreeSet<Integer> ts=new TreeSet<>();

           ts.add(20);

           ts.add(3);

           ts.add(11);

           ts.add(4);

           ts.add(1);

           System.out.println(ts); //[1,3,4,11,20]

           TreeSet ts1=(TreeSet)ts.descendingSet();

           System.out.println(ts1); //[20,11,4,3,1]

              }

}

 

To print individual elements of collection - 5 ways

1. Normal for loop

2. for each stmt

3. Using Iterator interface

        - used to print individual elements of collection only in forward direction

        - Using Iterator iterator(), we can create object for Iterator

        - Methods

           1. boolean hasNext() - check whether it contains next next elt

           2. Object next() - retrieve each elt

           3. void remove() - at time of accessing even we can remove the elt

 

4. Using ListIterator interface

       - used to print individual elements of collection both in forward and backward direction

        - Using ListIterator listIterator(), we can create object for ListIterator

        - Methods

           1. boolean hasNext() - check whether it contains next next elt

           2. Object next() - retrieve each elt

           3. void remove() - at time of accessing even we can remove the elt

           4. boolean hasPrevious()

           5. Object previous()

           6. void set(Object o)

           7. void add(Object o)

5. Using Enumeration interface

         - It is legacy interface

         - used to print individual elements of collection only in forward direction

        - Using Enumeration elements(), we can create object for Enumeration

        - Methods

           1. boolean hasMoreElements() - check whether it contains next next elt

           2. Object nextElement() - retrieve each elt

 

public class Main {

              public static void main(String...args) {

          List<Integer> l1=new ArrayList<>();

          l1.add(30);

          l1.add(20);

          l1.add(10);

          l1.add(24);

          System.out.println(l1);  //[30,20,10,24]

         

          //1. Normal FOR loop

          for(int i=0;i<l1.size();i++) {

                System.out.println(l1.get(i));

          }

         

          System.out.println("Using For each stmt");

          for(Integer i:l1)

                System.out.println(i);

         

          System.out.println("Using Iterator");

          Iterator<Integer> i=l1.iterator();

          while(i.hasNext()) {

                   // Integer i1=(Integer)i.next();

                     Integer i1=i.next();

                    System.out.println(i1);

          }

         

          List<Student> l2=new ArrayList<>();

          l2.add(new Student(1,"Ram",23));

          l2.add(new Student(2,"Sam",21));

          l2.add(new Student(3,"Tam",20));

          l2.add(new Student(4,"Jam",24));

         

          ListIterator<Student> li=l2.listIterator();

          while(li.hasNext()) {

                Student s1=li.next();

                System.out.println(s1.getName());

          }

          System.out.println();

          while(li.hasPrevious()) {

                Student s1=li.previous();

                System.out.println(s1.getName());

          }

         

          List<String> l3=new ArrayList<>();

          l3.add("Ram");

          l3.add("Sam");

          l3.add("Tam");

          ListIterator<String> lt=l3.listIterator();

          while(lt.hasNext()) {

                String s1=lt.next();

                lt.set(s1+"mmm");

          }

          while(lt.hasPrevious()) {

                String s1=lt.previous();

                System.out.println(s1);

          }

         

          Vector<Integer> v=new Vector<>();

              v.add(1);

              v.add(2);

              v.add(3);

              System.out.println(v); //[1,2,3]

              Enumeration e=v.elements();

              while(e.hasMoreElements()) {

                             System.out.println(e.nextElement());

              }

              }

}


Handson

 

1. Write a Java program to read all the player information from the user and display the player name and their cap number sorted based on their cap number (descending order). The contact details consist of player name, skill and cap number. Use Collections.sort() method for sorting.

 

Create a main class "Main.java"

Create Player class with below private  attributes

 

 

playerName - String

 

skill - String

 

capNumber - Long

 

Add appropriate getter and setter methods for Player class

Include a constructor for Player class with the arguments player name, skill and cap number

Implement Comparable interface and implement the method compareTo() to perform sorting based on cap number

 

Input and Output Format:

First input corresponds to the number of players and followed by each player's information.

Refer sample input and output for formatting specifications.

 

[All text in bold corresponds to input and the rest corresponds to output]

Sample Input/Output :

Enter number of players:

2

Enter player 1 detail

Enter Name

Suresh Raina

Enter Skill

Batsman

Enter Cap Number

265

Enter player 2 detail

Enter Name

Virat Kohli

Enter Skill

Batsman

Enter Cap Number

268

Player list after sorting by cap number in descending order

Virat Kohli-268

Suresh Raina-265

 

 

2.Comparator - no of matches player

 

Write a Java program to get the team name and number of matches played by the team from the user and display a report with team name and number of matches sorted based on the number of matches in ascending order. Use Collection.sort() method to perform the sorting in your main class. Send the Comparator object as second argument to the sort method to use this comparator for sorting.

 

Create a main class " Main.java"

Create a class named Team with the following private member variables / attributes,

name - String

numberOfMatches - Long

Include a constructor accepting Team name and number of matches as arguments

Add appropriate getter and setter methods for Team class

 

Create TeamComparator implementing Comparator interface

Implement compare method to compare two team objects based on their number of matches played.

 

Input and Output Format:

First input corresponds to the number of teams and followed by each team information.

Refer sample input and output for formatting specifications.

 

[All text in bold corresponds to input and the rest corresponds to output]

Sample Input/Output :

Enter number of teams:

3

Enter team 1 detail

Enter Name

Chennai super Kings

Enter number of matches

132

Enter team 2 detail

Enter Name

Royal Challengers Bangalore

Enter number of matches

139

Enter team 3 detail

Enter Name

Delhi Daredevils

Enter number of matches

131

Team list after sort by number of matches

131

132

139

 

 

 

Collections class

     - contain static methods/algorithm that support util package

 

Methods

1. static int binarySearch(List l,int val) - search any elet in list

2. static void copy(List dest,List src)

3. static List nCopies(int val,Object o) - create an immutable list with  list of values

4. static boolean disjoint(List l1,List l2) - return true if there is no common elt

5. static List emptyList() - create an immutable list

6. static Set emptySet() - create an immutable set

7. static Map emptyMap() - create an immutable map

8. static void fill(List l, Object o) - fill the list with particular value

9. static int frequency(List l, Object o) - return how many times an elt occur in the list

10. static boolean replaceAll(List l,Object oldval, Object newval)

11. static Object max(List l) - find max elt

12. static Object min(List l) - find min elt

13. static void reverse(List l)

14. static void shuffle(List l) - randomly shuffle elt

15. static List singletonList(Object o) - create list with single elt

16. static Set singleton(Object o)

17. static Map singletonMap(Object k, Object v)

18. static void sort(List l)

19. static void sort(List l,Comparator c)

20. static void swap(List l, int oldindex, int newindex)

21. static List synchronizedList(List l)

22. static Set synchronizedSet(Set s)

23. static Map synchronizedMap(Map m)

24. static List unmodifiableList(List l)

25. static Set unmodifiableSet(Set s)

26. static Map unmodifiableMap(Map m)

 

public class Main {

              public static void main(String...args) {

       List<Integer> l1=new ArrayList<>();

       l1.add(3);

       l1.add(5);

       l1.add(6);

       l1.add(7);

       l1.add(9);

       System.out.println(Collections.binarySearch(l1, 6)); //2

      

       List<String> l2=new ArrayList<>();

       l2.add("one");

       l2.add("two");

       l2.add("three");

       List<String> l3=new ArrayList<>();

       l3.add("four");

       l3.add("five");

       l3.add("six");

       //l3.add("seven");

      

       System.out.println(Collections.disjoint(l2, l3));  //true

       Collections.copy(l3, l2);

       System.out.println(l2);  //[one,two,three]

       System.out.println(l3);  //[one,two,three]

       System.out.println(Collections.disjoint(l2, l3)); //false

       

       List l4=Collections.nCopies(3, "Hello");

       System.out.println(l4); //[Hello,Hello,Hello]

       //l4.add("Hi");

       //System.out.println(l4); //UnsupportedOperationException

      

       List l5=Collections.emptyList();

       System.out.println(l5);  //[]

       //l5.add("Hi");

      // System.out.println(l5);  //exception

      

       System.out.println(Collections.frequency(l4, "Hello"));  //3

       Collections.fill(l3,"Hi");

       System.out.println(l3); //[Hi,Hi,Hi]

       Collections.replaceAll(l3, "Hi", "He");

       System.out.println(l3);  //[He,He,He]

      

       List<String> l6=new ArrayList<>();

       l6.add("Hii");

       l6.add("Hi");

       l6.add("Hiiii");

       l6.add("Hi Good monring");

       Collections.replaceAll(l6, "Hi", "He");

       System.out.println(l6);  //[Hii,He,Hiiii,Hi Good morning]

      

       List<Integer> l7=new ArrayList<>();

       l7.add(8);

       l7.add(-20);

       l7.add(-8);

       l7.add(20);

       System.out.println(l7);  //[8,-20,-8,20]

      

      Collections.reverse(l7);

      System.out.println(l7);  //[20,-8,-20,8]

      System.out.println(Collections.max(l7));  //20

      System.out.println(Collections.min(l7)); //-20

     

      Collections.shuffle(l7);

      System.out.println(l7);  //random order

      Collections.sort(l7); //ascending order

      System.out.println(l7); //[-20,-8,8,20]

 

      Collections.sort(l7,Comparator.reverseOrder()); //descending order

      System.out.println(l7); //[20,8,-8,-20]

     

      Collections.swap(l7, 0, 3);

      System.out.println(l7); //[20,-8,8,-20]

     

      l7=Collections.singletonList(23);

      System.out.println(l7); //[23]

      //l7.add(24);

     // System.out.println(l7);  //exception

     

      List l8=Collections.synchronizedList(l6);

      System.out.println(l8);  //threadsafe

     

      List l9=Collections.unmodifiableList(l2);

      System.out.println(l9);  //[one,two,three] - immutable

      l9.add("Hello");

      System.out.println(l9); //exception

              }

}

 

Arrays class

    - used to perform operation on any datatype array

 

Methods

1. static List asList(int[] a) - convert int array to List

2. static void fill(int[] a, int val) - fill all elts of array with val

3. static void fill(int[] a,int start,int end,int val) - fill elt with val from start to end-1

4. static void sort(int[] a) - sort all elts of array

5. static void sort(int[] a, int start,int end) - sort elts from start to end

6. static boolean equals(int[] a1,int[] a2)

7. static int binarySearch(int[] a,int val)

 

public class Main {

              public static void main(String...args) {

        Integer a[]=new Integer[10];

        for(int i=0;i<10;i++) {

              a[i]=i*-3;

        }

        for(int a1:a)

              System.out.println(a1);

       

        List<Integer> l=Arrays.asList(a);

        System.out.println(l); // [0,-3,-6,-9,-12,-15,-18,-21,-24,-27]

       

        Arrays.sort(a); //[-27,-24,-21,-18,-15,-12,-9,-6,-3,0]

        System.out.println(Arrays.binarySearch(a, -15)); //4

       

        //If value is not present it returns negative value based on -(index)-1

        //[-27,-24,-21,-18,-15,-12,-10,-9,-6,-3,0] = -(6)-1

        System.out.println(Arrays.binarySearch(a, -10)); //-7

        //[-27,-24,-22,-21,-18,-15,-12,-10,-9,-6,-3,0] = -(2)-1

        System.out.println(Arrays.binarySearch(a, -22));  //-3

       

        Arrays.sort(a); //[-27,-24,-21,-18,-15,-12,-9,-6,-3,0]

        Arrays.fill(a,2,5,-1); //start to end-1 by -1

          //[-27,-24,-1,-1,-1,-12,-9,-6,-3,0]

        Arrays.sort(a,2,5); //[-27,-24,-12,-1,-1,-1,-9,-6,-3,0]

        Arrays.sort(a); //[-27,-24,-12,-9,-6,-3,-1,-1,-1,0]

              }

}

 

- If we want to sort the elts of List interface, we have to use Collections.sort(List l)

- If we want to sort the elts of Set interface, we have to use TreeSet class

- If it is numbers then it will sorted in ascending order and String means it will sorted in alphabetical order

 

Comparable and Comparator interface

     - If ur List or Set interface contains collection of user defined object like Employee, Student, Player etc, now we want to sort based on their properties rather than sorting its reference

 

List<Employee> l=new ArrayList<>();

empid,ename,salary,age - properties

 

Comparable interface                                      Comparator interface

1. provides single sorting sequence         1. provides multiple sorting

(ie) we can do sorting based on             sequence (ie) we can do sorting

only property either by empid               based on empid and name and salary

or ename or salary or age                   age

 

2. present in java.lang.*                   2. present in java.util.*

 

3. int compareTo(Object o)                 3. int compare(Object o1,Object o2)

 

4. We do sorting using                     4. We do sorting using

Collections.sort(List l) for             Collections.sort(List l,Comparator c)

List intf and TreeSet class for          for List intf and

Set intf                                 TreeSet(Comparator c) for Set intf

 

 

public class Student implements Comparable<Student> {

   private Integer stuId;

   private String name;

   private Integer age;

public Integer getStuId() {

              return stuId;

}

public void setStuId(Integer stuId) {

              this.stuId = stuId;

}

public String getName() {

              return name;

}

public void setName(String name) {

              this.name = name;

}

public Integer getAge() {

              return age;

}

public void setAge(Integer age) {

              this.age = age;

}

public Student(Integer stuId, String name, Integer age) {

              super();

              this.stuId = stuId;

              this.name = name;

              this.age = age;

}

public Student() {

              super();

              // TODO Auto-generated constructor stub

}

@Override

public int compareTo(Student o) {

              // TODO Auto-generated method stub

              return name.compareTo(o.name);

}

/*@Override

public int compareTo(Student o) {

              if(age==o.age)

                 return 0;

              else if(age>o.age)

                             return 1;

              else

                             return -1;

}*/

@Override

public String toString() {

              return "Student [stuId=" + stuId + ", name=" + name + ", age=" + age + "]";

}

  

}

 

public class Employee {

              Integer eId;

                 String name;

                  Integer age;

              public Integer getEId() {

                             return eId;

              }

              public void setEId(Integer eId) {

                             this.eId = eId;

              }

             

              public String getName() {

                             return name;

              }

              public void setName(String name) {

                             this.name = name;

              }

              public Integer getAge() {

                             return age;

              }

              public void setAge(Integer age) {

                             this.age = age;

              }

              public Employee(Integer eId, String name, Integer age) {

                             super();

                             this.eId = eId;

                             this.name = name;

                             this.age = age;

              }

              public Employee() {

                             super();

                             // TODO Auto-generated constructor stub

              }

              @Override

              public String toString() {

                             return "Employee [eId=" + eId + ", name=" + name + ", age=" + age + "]";

              }

             

             

                

}

 

 

public class AgeComparator implements Comparator<Employee> {

 

              @Override

              public int compare(Employee o1, Employee o2) {

                             if(o1.age==o2.age)

                                return 0;

                             else if(o1.age>o2.age)

                                           return 1;

                             else

                                           return -1;

              }

 

}

 

 

public class NameComparator implements Comparator<Employee>{

 

              @Override

              public int compare(Employee o1, Employee o2) {

                             return o1.name.compareTo(o2.name);

              }

 

}

 

public class Main {

              public static void main(String...args) {

        List<Integer> l1=new ArrayList<>();

        l1.add(4);

        l1.add(2);

        l1.add(5);

        l1.add(1);

        l1.add(6);

        System.out.println(l1);  //[4,2,5,1,6]

        Collections.sort(l1);

        System.out.println(l1);  //[1,2,4,5,6]

        Collections.sort(l1,Comparator.reverseOrder());

        System.out.println(l1);  //[6,5,4,2,1]

       

        TreeSet<String> ts=new TreeSet<>();

        ts.add("H");

        ts.add("B");

        ts.add("E");

        ts.add("A");

        System.out.println(ts); //[A,B,E,H]

        TreeSet ts1=(TreeSet) ts.descendingSet();

        System.out.println(ts1); //[H,E,B,A]

       

        List<Student> l2=new ArrayList<>();

       l2.add(new Student(103,"Ram",24));

        l2.add(new Student(101,"Sam",20));

        l2.add(new Student(104,"Raj",21));

        l2.add(new Student(100,"Tam",23));

        l2.add(new Student(102,"Jam",19));

       

        Collections.sort(l2);  //internally calls compareTo

        for(Student s1:l2)

              System.out.println(s1);

       

        System.out.println();

        TreeSet<Student> ts2=new TreeSet<>();

        ts2.add(new Student(103,"Ram",24));

        ts2.add(new Student(101,"Sam",20));

        ts2.add(new Student(104,"Raj",21));

        ts2.add(new Student(100,"Tam",23));

        ts2.add(new Student(102,"Jam",19));

        for(Student s1:ts2)

              System.out.println(s1);

       

        List<Employee> l3=new ArrayList<>();

        l3.add(new Employee(103,"Ram",24));

        l3.add(new Employee(101,"Sam",20));

        l3.add(new Employee(104,"Raj",21));

        l3.add(new Employee(100,"Tam",23));

        l3.add(new Employee(102,"Jam",19));

       

        Collections.sort(l3,new AgeComparator());

        for(Employee e1:l3)

              System.out.println(e1.getAge());

       

        System.out.println();

        Collections.sort(l3,new NameComparator());

        for(Employee e1:l3)

              System.out.println(e1.getName());

       

        System.out.println();

        TreeSet<Employee> ts3=new TreeSet<>(new AgeComparator());

        ts3.add(new Employee(103,"Ram",24));

        ts3.add(new Employee(101,"Sam",20));

        ts3.add(new Employee(104,"Raj",21));

        ts3.add(new Employee(100,"Tam",23));

        ts3.add(new Employee(102,"Jam",19));

        for(Employee e1:ts3)

              System.out.println(e1);

              }

}

 

Map interface

      - used to store collection of object but in the form of unique key value pair

      - Map is unordered

 

Methods

1. void put(Object k,Object v) - insert single key value pair

2. void putAll(Map m) - store multiple key value pair

3. Object putIfAbsent(Object k,Object v) - if specified key is not associated with the value then it associates the key with given value and returns null

4. boolean containsKey(Object k)

5. boolean containsValue(Object v)

6. Object get(Object k) - if we provide the key, it will return value associated with that key

7. Object getOrDefault(Object k,Object defaultvalue)

8. Object remove(Object k) - if we provide the key, it will remove value associated with that key

9. boolean remove(Object k,Object v)

10. Object replace(Object k,Object v)

11. boolean replace(Object k, Object oldval, Object newval)

12. boolean isEmpty()

13. int size()

14. Set entrySet()

15. Set keySet()

 

Map.Entry interface

    - used to describe key and value separately

Methods

1. Object getKey()

2. Object getValue()

3. Object setValue(Object k)

 

SortedMap interface

      - used to sort the elements of Map interface

Methods

1. Object firstKey()

2. Object lastKey()

3. SortedMap subMap(Object start,Object end) - start to end-1

4. SortedMap headMap(Object k)

5. SortedMap tailMap(Object k)


Handson

 

1.TreeMap-Player Details

 

BCCI, for the upcoming IPL season in 2017 decided to give  unique cap numbers to every player. Player capNumber is a string. The capNumber  and player details are stored in a Treemap.

Create a class named Player with the following private attributes --- name,team and skill. Create a list of objects of Player type.

Cap number is the key and player details is the value. Write a program to display the details of all the players stored in this TreeMap.

Input and Output Format:

  

Refer sample input and output for formatting specifications.

All text in bold corresponds to input and the rest corresponds to output.

 

Sample Input and Output:

Enter the number of players

2

Enter the details of the player 1

57

Jaspirit Bumrah

Mumbai Indians

Bowler

Enter the details of the player 2

55

MS Dhoni

Rising Pune Supergiants

All Rounder

Player Details

55--MS Dhoni--Rising Pune Supergiants--All Rounder

57--Jaspirit Bumrah--Mumbai Indians--Bowler

 

2.TreeMap-Player Details

 

BCCI, for the upcoming IPL season in 2017 decided to give  unique cap numbers to every player. Player capNumber is a string. The capNumber  and player details are stored in a Treemap.

Create a class named Player with the following private attributes --- name,team and skill. Create a list of objects of Player type.

Cap number is the key and player details is the value. Write a program to display the details of all the players stored in this TreeMap and details of the players by searching based on cap number.

Input and Output Format:

 

Refer sample input and output for formatting specifications.

All text in bold corresponds to input and the rest corresponds to output.

 

Sample Input and Output 1:

Enter the number of players

2

Enter the details of the player 1

57

Jaspirit Bumrah

Mumbai Indians

Bowler

Enter the details of the player 2

55

MS Dhoni

Rising Pune Supergiants

All Rounder

Player Details

55--MS Dhoni--Rising Pune Supergiants--All Rounder

57--Jaspirit Bumrah--Mumbai Indians--Bowler

Enter the cap number of the player to be searched

55

Player Details

MS Dhoni--Rising Pune Supergiants--All Rounder

 

 

 

Sample Input and Output 2:

Enter the number of players

2

Enter the details of the player 1

57

Jaspirit Bumrah

Mumbai Indians

Bowler

Enter the details of the player 2

55

MS Dhoni

Rising Pune Supergiants

All Rounder

Player Details

55--MS Dhoni--Rising Pune Supergiants--All Rounder

57--Jaspirit Bumrah--Mumbai Indians--Bowler

Enter the cap number of the player to be searched

34

Player Details

Player not found

 

 

Map interface

      - used to store collection of object but in the form of unique key value pair

      - Map is unordered

 

Methods

1. void put(Object k,Object v) - insert single key value pair

2. void putAll(Map m) - store multiple key value pair

3. Object putIfAbsent(Object k,Object v) - if specified key is not associated with the value then it associates the key with given value and returns null

4. boolean containsKey(Object k)

5. boolean containsValue(Object v)

6. Object get(Object k) - if we provide the key, it will return value associated with that key

7. Object getOrDefault(Object k,Object defaultvalue)

8. Object remove(Object k) - if we provide the key, it will remove value associated with that key

9. boolean remove(Object k,Object v)

10. Object replace(Object k,Object v)

11. boolean replace(Object k, Object oldval, Object newval)

12. boolean isEmpty()

13. int size()

 

We cant apply Iterator interface directly on Map interface, we have to convert Map to Set interface

14. Set entrySet() - convert both key and value to Set interface

15. Set keySet() - convert only keys to Set interface

 

Map.Entry interface

    - used to describe key and value separately

Methods

1. Object getKey()

2. Object getValue()

3. Object setValue(Object k)

 

SortedMap interface

      - used to sort the elements of Map interface

Methods

1. Object firstKey()

2. Object lastKey()

3. SortedMap subMap(Object start,Object end) - start to end-1

4. SortedMap headMap(Object k)

5. SortedMap tailMap(Object k)

 

 

3 classes

1. HashMap class

        - uses hashing technique to print the value in random order and contains key value pairs

        - default capacity is 16

        - allow one null key allowed and any number of null values

 

Syntax: public class HashMap extends AbstractMap implements Map, Cloneable, Serializable

 

Constructor

   1. HashMap()

   2. HashMap(int capacity)

   3. HashMap(int capacity, float fillratio)

   4. HashMap(Map m)

 

Map<Employee,String> hm=new HashMap<>();

 

So when we create an object for HashMap, internally it creates a bucket from 0 to 15. Each bucket internally considered as LinkedList, this LinkedList contains one node, the internal structure of node will have key,value,hashcode,next

 

Employee e1=new Employee(1,"Ram");

Employee e2=new Employee(2,"Sam");

Employee e3=new Employee(3,"Tam");

Employee e4=new Employee(4,"Jam");

 

hm.put(e1,"HR");

 

So when we call put(), first it calculate hashcode for the key using hashCode() (ie) hashCode(e1) = 2000

Next it will calculate the index using index=hashcode(key) & (n-1)

                                            =2000 & (16-1) = 2000 & 15 = 6

 

it stores e1 in index 6

 

hm.put(e2,"Operation");

 

So when we call put(), first it calculate hashcode for the key using hashCode() (ie) hashCode(e2) = 1000

Next it will calculate the index using index=hashcode(key) & (n-1)

                                            =1000 & (16-1) = 1000 & 15 = 9

it stores e2 in index 9

 

hm.put(e3,"Admin");

 

So when we call put(), first it calculate hashcode for the key using hashCode() (ie) hashCode(e3) = 2000

Next it will calculate the index using index=hashcode(key) & (n-1)

                                            =2000 & (16-1) = 2000 & 15 = 6

it stores e3 in index 6

 

If same bucket contains multiple node then that is called as Hashing collision, so map will not directly add the entry into the bucket, since both key have same index, map internally calls equals() and check whether the content is same or different, if it is different it will store the entry into same bucket and if it is same it will replace the entry

 

hm.put(null,"IT");

If we pass key as null, then entry will be directly stored inside 0th bucket

 

How searching works in LinkedList?

 

item1:P->item2:P->item3:P->item4:P

 

get() of HashMap will return the  value very faster

when we call hm.get(key), first JVM will find hashcode(key) and from hashcode we can find the bucket index,so jvm will directly goes to the index and find the value, so we use Hashmap because of time complexity

    In general, HashMap index can contain multiple nodes in single bucket, ideally have only one node in one bucket. In hash collision, JVM will traverse one by one to fetch the elt, so performance is slow

    From Java8, HashMap has been enhanced to reduce the time when using get()

 

Map<Integer,String> hm1=new HashMap<>();

hm1.put(4,"a");

hm1.put(6,"a");

hm1.put(2,"a");

hm1.put(7,"a");

hm1.put(1,"a");

hm1.put(5,"a");

hm1.put(3,"c");

Consider all keys have same hashcode so all will have same index in bucket, so performance slow

 

In Java8, it will convert LinkedList into tree structure, when no of node reaches certain threshold and that threshold is called Treeify threshold

Map<Integer,Integer> hm1=new HashMap<>();

hm1.put(4,4);

hm1.put(6,6);

hm1.put(2,2);

hm1.put(7,7);

hm1.put(1,1);

hm1.put(5,5);

hm1.put(3,3);

 

Hence we store integer it takes bigger or smaller, in case of String or object values, so JVM will determine that particular object is greater or smaller using compareTo()

 

public class Main {

 

              public static void main(String[] args) {

                             Map<Integer,String> hm=new HashMap<>();

                             System.out.println(hm.size());  //0

                             hm.put(10, "apple"); 

                             hm.put(13, "grapes");

                             hm.put(15, "banana");

                             hm.put(16, "Guava");

                             hm.put(10, "mango"); //no error, the value will be overridden

                             System.out.println(hm.size());  //4

                             System.out.println(hm); //print in curly braces, in random order

                            

                             System.out.println(hm.putIfAbsent(20, "Melon")); //null

                             System.out.println(hm.putIfAbsent(11, "Berry")); //null

                             System.out.println(hm.putIfAbsent(10, "Lime")); //mango

                             System.out.println(hm.size());  //6

                             System.out.println(hm.get(16)); //Guava

                             System.out.println(hm.get(17));  //null

                             System.out.println(hm.getOrDefault(17, "Pineapple")); //Pineapple

                             System.out.println(hm.size()); //6

                             hm.remove(10);

                             System.out.println(hm.get(10)); //null

                             System.out.println(hm.remove(11, "Berry")); //true

                             System.out.println(hm.get(11)); //null

                             System.out.println(hm.remove(13,"Berry")); //false

                             System.out.println(hm.get(13)); //grapes

                            

                             System.out.println(hm.replace(16, "Guava", "Orange")); //true

                             System.out.println(hm.get(16)); //Orange

                             System.out.println(hm.replace(20, "Greenapple")); //Melon

                             System.out.println(hm.get(20)); //Greenapple

                             System.out.println(hm);

                            

                             Set set=hm.entrySet();  //convert both key and value to Set intf

                             Iterator itr=set.iterator();

                             while(itr.hasNext()) {

                                              Map.Entry me=(Map.Entry)itr.next();  //one key value pair

                                              System.out.println(me.getKey()+" "+me.getValue());

                             }

                            

                             set=hm.keySet();  //convert only key to Set intf

                             Iterator<Integer> itr1=set.iterator();

                  while(itr1.hasNext()) {

                            Integer key=itr1.next();  //one key

                            System.out.println(key+" "+hm.get(key));

                  }

              }

 

}

 

2. LinkedHashMap class

      - maintain the insertion order

 

Syntax: public class LinkedHashMap extends HashMap

 

Constructor

   1. LinkedHashMap()

   2. LinkedHashMap(int capacity)

   3. LinkedHashMap(int capacity, float fillratio)

   4. LinkedHashMap(Map m)

 

3. TreeMap class

     - used to sort the elemts only based on key

     - u cant add null key, we can have null values

 

Syntax: public class TreeMap extends AbstractMap implements NavigableMap, Cloneable, Serializable

 

4. HashTable class

      - It is a legacy class

      - similar to HashMap but it is synchronized or threadsafe

 

Syntax: public class Hashtable extends Dicitionary implements Map, Cloneable, Serializable

 

Constructor

   1. Hashtable()

   2. Hashtable(int capacity)

   3. Hashtable(int capacity, float fillratio)

   4. Hashtable(Map m)

 

5. Properties class

      - contains key value pairs but both key and value should be in the form of String, print in random order

 

Syntax:  public class Properties extends Hashtable

 

Constructor

  1.Properties()

  2.Properties(String default)

 

public class Main {

 

              public static void main(String[] args) {

                             LinkedHashMap<Integer,String> hm=new LinkedHashMap<>();

                             System.out.println(hm.size());  //0

                             hm.put(10, "apple"); 

                             hm.put(13, "grapes");

                             hm.put(15, "banana");

                             hm.put(16, "Guava");

                             hm.put(10, "mango"); //no error, the value will be overridden

                             System.out.println(hm);

                            

                             TreeMap<String,Integer> tm=new TreeMap<>();

                             tm.put("lion",10);

                             tm.put("cat",30);

                             tm.put("ape",20);

                             tm.put("bear",40);

                             System.out.println(tm);

                            

                             Hashtable<Integer,Double> ht=new Hashtable<>();

                             System.out.println(ht.size());

                             ht.put(3, 2.45);

                             ht.put(1, 5.67);

                             ht.put(6, 4.23);

                             ht.put(7, 1.23);

                             System.out.println(ht);

                            

                             Enumeration<Integer> e=ht.keys();

                             while(e.hasMoreElements()) {

                                           Integer key=e.nextElement();

                                           System.out.println(key+" "+ht.get(key));

                             }

                            

                             Properties p=new Properties();

                             p.put("cat", "milk");

                             p.put("dog", "meat");

                             p.put("cow", "grass");

                             p.put("fish", "water");

                             System.out.println(p);

                            

                             Set set=p.keySet();  //only key

                             Iterator<String> itr=set.iterator();

                             while(itr.hasNext()) {

                                           String key=itr.next();

                                           System.out.println(key+" "+p.getProperty(key));

                             }
              }
}


Handson

 

1. The Chennai Super Kings were the most successful team in the IPL with a win percentage of 60.68 and had won the title twice in succession (2010 and 2011).

 

The CSKs have played “n” matches so far in IPLs. Given the number of matches “n” that CSK has played and their team score in the matches as a list, write a program to find the total runs and the average runs scored by the team in all “n” matches.

 

Input Format:

First line of the input is an integer “n” that corresponds to the number of matches played by CSK.

Next “n” lines contains an integer in each line, that corresponds to the runs scored by CSK in each of the “n” matches.

 

Output Format:

Output should print in the first line the integer that gives the total runs scored by CSK in the matches.

In the second line, print a float value that gives the average runs.

 

Sample Input :

5

200

210

180

176

192

 

Sample Output :

958

191.6

 

 

2.  A measure of a batsman's greatness is his ability to score runs on foreign conditions. It is quite obvious in Cricket that most batsmen have been excellent at home grounds but flops overseas. Consequently not many teams have aggregates balanced in terms of home and away performances.

 

Sunil now wanted to analyze the performance of IPL teams based on the runs scored in home as well away matches. Given are the team name, number of matches played by the team in home ground “n” and away grounds “m” respectively, runs scored by the team in each of the matches both home and away respectively. Write a program to store the runs scored by the team in both home ground and in other grounds in a list and help Sunil to display the score (in both home and away grounds) of the team that is greater than 300.

 

Input Format:

 

First line of the input contains a string that gives the name of the IPL team.

 

Second line of input contains the integer “n” that corresponds to the number of matches played by the team in home grounds.

 

Next “n” lines contains the runs scored by the team in each of the matches in home grounds.

 

Next line that follows contains the integer “m” that corresponds to the number of matches played by the team in away grounds.

 

Next “m” lines contains the runs scored by the team in each of the matches in away grounds.

 

Output Format:

 

Output should display the runs scored by the team in both home ground and in other grounds as a list, line after line.

 

In the lines to follow, the output should display the score (in both home and away grounds) of the team that is greater than 300, line after line.

 

Sample Input and output :

 

Enter the team name

Chennai Super Kings

Enter the number of matches played in home ground

2

Enter the runs scored

290

320

Enter the number of matches played in other ground

3

Enter the runs scored

399

180

150

Runs scored by Chennai Super Kings

290

320

399

180

150

Run scored by Chennai Super Kings more than 300

320

399

 

 

java.util.*

    - Utility framework or collection framework

    - used to store collection of objects - any objects (ie) Employee, Student, String, Player, Venue

 

1. Collection interface - core interface in order to store collection of object

2. Collections class - provided with static methods or static algorithm that supports util package

 

Collection interface

      - core interface in order to store collection of object

 

Methods

1. boolean add(Object o) - add single object

2. boolean addAll(Collection c) - add multiple object

3. boolean remove(Object o) - remove single object

4. boolean removeAll(Collection c) - remove multiple object

5. boolean contains(Object o) - check single object present in Collection or not

6. boolean containsAll(Collection c) - check multiple object present in Collection or not

7. boolean retainAll(Collection c)- remove from the target collection all the elemts that are not contained in the specified collection

8. int size() - return number of objects present in the collection

9. boolean isEmpty() - to check collection is empty or not

10. Object[] toArray() - return a array containing all elts in collection

11. String toString()

12. boolean equals(Object o)

13. Iterator iterator()

14. ListIterator listIterator()

 

List interface

    - Ordered and duplicate elements allowed

 

Methods

1. void add(int index,Object o) - add single object at particular index position

2. boolean addAll(int index,Collection c) - add multiple object at particular index position

3. Object get(int index) - return single object present at particular index position

4. int indexOf(Object o) - return position of first occurence of object in given collection

5. int lastIndexOf(Object o) - return position of last occurence of object in given collection

6. Object remove(int index) - remove single object present at particular index position

7. Object set(int index,Object val) - replace an object at particular index

8. List subList(int start,int end) - return part of list from start to end-1

 

Set interface

     - unordered and no duplicate elets allowed

 

SortedSet interface

     - sort the elts of Set interface

 

Methods

1. Object first() - return first elt

2. Object last() - return last elt

3. SortedSet subSet(Object from, Object end) - return part of set from start to end-1

4. SortedSet headSet(Object elt) - return all elts present before specified elt

    (1 2 3 4 5).headSet(3)  //1 2

 

5. SortedSet tailSet(Object elt) - return all elts present after specified elt

    (1 2 3 4 5).tailSet(3)  //4 5

 

List interface

     - Ordered and duplicate elements allowed

 

int a[]=new int[3];   - Static array

 

1. ArrayList class

        - It is similar to array but it is called as dynamic array (ie) we can increase or decrease its size at runtime

 

Syntax: public class ArrayList extends AbstractList implements List, Cloneable, Serializable, RandomAccess

 

        - used for faster retrieval of data and slower in insertion and deletion

        - default capacity is 10

 

Constructor

   1. ArrayList()

   2. ArrayList(int capacity)

   3. ArrayList(Collection c)

 

public class Main {

              public static void main(String...args) {

                  ArrayList l1=new ArrayList();

                  System.out.println(l1.size());  //0

                  l1.add("A");

                  l1.add("B");

                  l1.add(10);   //Autoboxing

                  System.out.println(l1.size());  //3

                  //wheneever we print object of any collection inside []

                  System.out.println(l1); //[A,B,10]

                 

                  ArrayList l2=new ArrayList();

                  System.out.println(l2.size()); //0

                  l2.addAll(l1);

                  System.out.println(l2); //[A,B,10]

                 

                  System.out.println(l1.contains(10));  //true

                  System.out.println(l1.containsAll(l2)); //true

                  System.out.println(l1.indexOf(10)); //2

                 

                  List l3=new ArrayList();  //DMD

                  l3.add("A");

                  l3.add("B");

                  l3.add(1);

                  l3.add(2);

                  l3.add(3);

                  System.out.println(l3);  //[A,B,1,2,3]

                 

                  List l4=new ArrayList();

                  l4.add("A");

                  l4.add("B");

                  l4.add(1);

                  System.out.println(l4); //[A,B,1]

                 

                  l3.retainAll(l4);

                  System.out.println(l3); //[A,B,1]

              }

}

 

Generics

    - Available from JDK1.5 onwards

    - used to specify what type of object stored in the collection, avoid type casting

    - denoted by <>

 

List<String> l1=new ArrayList<String>();  //JDK1.5

List<Integer> l2=new ArrayList<>(); //From JDK1.7

 

public class Main {

              public static void main(String...args) {

                List<String> l1=new ArrayList<>();

                System.out.println(l1.size());  //0

                l1.add("C");

                l1.add("F");

                l1.add(1,"O");

                l1.add("T");

                l1.add("R");

                //C,O,F,T,R

                System.out.println(l1); //[C,O,F,T,R]

                System.out.println(l1.get(2));  //F

                System.out.println(l1.contains("S"));  //false

                List<String> l2=new ArrayList<>();

                l2.add("C");

                l2.add("F");

                System.out.println(l1.containsAll(l2)); //true

                System.out.println(l1.indexOf("T")); //3

                l1.remove("T");  //[C,O,F,R]

                l1.remove(1);

                System.out.println(l1); //[C,F,R]

               

              }

}

 

2. LinkedList class

       - It is also called dynamic array

       - used for faster insertion and deletion, slower in selection

 

Syntax: public class LinkedList extends AbstractSequentialList implements List, Cloneable, Serailizable, Deque

 

Deque - Double Ended Queue - do insertion and deletion at both ends

 

Constructors

    1. LinkedList()

    2. LinkedList(Collection c)

   

Methods

1. void addFirst()

2. void addLast()

3. Object getFirst()

4. Object getLast()

5. Object removeFirst()

6. Object removeLast()

7. void push(Object o)

8. Object pop()

9. boolean offerFirst(Object o) - insert specified elt front of the list

10. boolean offerLast(Object o) - insert specified elt last of the list

11. Object peekFirst() - retrieves first elt of the list but does not remove

12. Object peekLast() - retrieves last elt of the list but does not remove

13. Object pollFirst() - retrieves first elt of the list and remove

14. Object pollLast() - retrieves last elt of the list and remove

 

public class Main {

              public static void main(String...args) {

                LinkedList<Integer> l1=new LinkedList<>();

                l1.add(3);

                l1.add(5);

                l1.add(2);

                l1.add(1,7);

                l1.addFirst(8);

                l1.addLast(9);

                System.out.println(l1.size()); //6 

                System.out.println(l1); //[8,3,7,5,2,9]

                System.out.println(l1.get(5)); //9

                System.out.println(l1.getFirst()); //8

                System.out.println(l1.getLast()); //9

                l1.remove(1); //8,7,5,2,9

                l1.removeFirst(); //7,5,2,9

                l1.removeLast();

                System.out.println(l1); //[7,5,2]

                System.out.println(l1.peekFirst()); //7

                System.out.println(l1.pollLast()); //2

                System.out.println(l1); //[7,5]

              }

}

 

3. Vector class

      - It is a legacy(older) class

      - It is also called dynamic array, but it is synchronized or threadsafe

      - Default capacity is 10

 

Syntax: public class Vector extends AbstractList implements List,Cloneable, Serailizable

 

Constructor

   1. Vector()

   2. Vector(int capacity)

   3. Vector(int capacity,int increment)

   4. Vector(Collection c)

 

public class Main {

              public static void main(String...args) {

                  Vector<Integer> v=new Vector<>(3,2);

                  System.out.println(v.size()); //0

                  System.out.println(v.capacity()); //3

                  v.add(1);

                  v.add(2);

                  v.add(3);

                  v.add(4);

                  System.out.println(v.size()); //4

                  System.out.println(v.capacity()); //5

                  v.add(5);

                  v.add(6); //5+2

                  System.out.println(v.size()); //6

                  System.out.println(v.capacity()); //7

                  System.out.println(v); //[1,2,3,4,5,6]

              }

}

 

Set interface

    - unordered and no duplicates allowed

 

1. HashSet class

      - does not maintain any insertion order and the elts are inserted in the basis of their hashcode value

      - default capacity is 16

 

Syntax: public class HashSet extends AbstractSet implements Set, Cloneable, Serializable

 

Constructor

   1. HashSet()

   2. HashSet(int capacity)

   3. HashSet(int capacity,float fillratio)

       fillratio ranges from 0.0 to 1.0 - default is 0.75

   4. HashSet(Collection c)

 

Set<Integer> hs=new HashSet<>();       Map<Integer,Object> hm=new HashMap<>();

sop(hs.size()); //0

hs.add(2);                             hm.put(2,PRESENT);

hs.add(3);                             hm.put(3,PRESENT);

hs.add(2);                             hm.put(2,PRESENT);

sop(hs.size());  //2

sop(hs); //[2,3]

 

When we create HashSet, it internally creates HashMap(unique key value pair), with key as what elt we are inserting into the hashset and value as dummy object called PRESENT

 

If hm.put(key,value) returns null then the statement hm.put(2,PRESENT)==null will return true then the element will be added into hashset

 

If hm.put(key,value) returns old value of key then the statement hm.put(2,PRESENT)==null will return false then the element will not be added into hashset

 

Set<Integer> hs=new HashSet<>(3);

hs.add(1);

hs.add(2);

hs.add(3);

hs.add(4);  3*0.75=2.25+3=5.25

hs.add(5);

hs.add(6); 5.25*0.75=3+5.25=8.25

 

2. LinkedHashSet class

        - used to maintain the insertion order of the set

 

Syntax: public class LinkedHashSet extends HashSet implements Set,Cloneable, Serializable

 

Constructor

   1. LinkedHashSet()

   2. LinkedHashSet(int capacity)

   3. LinkedHashSet(int capacity,float fillratio)

       fillratio ranges from 0.0 to 1.0 - default is 0.75

   4. LinkedHashSet(Collection c)

 

3. TreeSet class

       - Print the elements of Set interface in Sorted format(ie)numbers in ascending, string in alphabetical order

 

Syntax: public class TreeSet extends AbstractSet implements NavigableSet, Cloneable, Serializable

 

Constructor

   1. TreeSet()

   2. TreeSet(Comparator c)

   3. TreeSet(Collection s)

   4. TreeSet(SortedSet s)

 

public class Main {

              public static void main(String...args) {

          Set<Integer> hs=new HashSet<>();

           hs.add(20);

           hs.add(3);

           hs.add(11);

           hs.add(4);

           hs.add(1);

           System.out.println(hs); //random order

          

           LinkedHashSet<Integer> ls=new LinkedHashSet<>();

           ls.add(20);

           ls.add(3);

           ls.add(11);

           ls.add(4);

           ls.add(1);

           System.out.println(hs); //[20,3,11,4,1]

          

           TreeSet<Integer> ts=new TreeSet<>();

           ts.add(20);

           ts.add(3);

           ts.add(11);

           ts.add(4);

           ts.add(1);

           System.out.println(ts); //[1,3,4,11,20]

           TreeSet ts1=(TreeSet)ts.descendingSet();

           System.out.println(ts1); //[20,11,4,3,1]

              }

}

 

To print individual elements of collection - 5 ways

1. Normal for loop

2. for each stmt

3. Using Iterator interface

        - used to print individual elements of collection only in forward direction

        - Using Iterator iterator(), we can create object for Iterator

        - Methods

           1. boolean hasNext() - check whether it contains next next elt

           2. Object next() - retrieve each elt

           3. void remove() - at time of accessing even we can remove the elt

 

4. Using ListIterator interface

       - used to print individual elements of collection both in forward and backward direction

        - Using ListIterator listIterator(), we can create object for ListIterator

        - Methods

           1. boolean hasNext() - check whether it contains next next elt

           2. Object next() - retrieve each elt

           3. void remove() - at time of accessing even we can remove the elt

           4. boolean hasPrevious()

           5. Object previous()

           6. void set(Object o)

           7. void add(Object o)

5. Using Enumeration interface

         - It is legacy interface

         - used to print individual elements of collection only in forward direction

        - Using Enumeration elements(), we can create object for Enumeration

        - Methods

           1. boolean hasMoreElements() - check whether it contains next next elt

           2. Object nextElement() - retrieve each elt

 

public class Main {

              public static void main(String...args) {

          List<Integer> l1=new ArrayList<>();

          l1.add(30);

          l1.add(20);

          l1.add(10);

          l1.add(24);

          System.out.println(l1);  //[30,20,10,24]

         

          //1. Normal FOR loop

          for(int i=0;i<l1.size();i++) {

                System.out.println(l1.get(i));

          }

         

          System.out.println("Using For each stmt");

          for(Integer i:l1)

                System.out.println(i);

         

          System.out.println("Using Iterator");

          Iterator<Integer> i=l1.iterator();

          while(i.hasNext()) {

                   // Integer i1=(Integer)i.next();

                     Integer i1=i.next();

                    System.out.println(i1);

          }

         

          List<Student> l2=new ArrayList<>();

          l2.add(new Student(1,"Ram",23));

          l2.add(new Student(2,"Sam",21));

          l2.add(new Student(3,"Tam",20));

          l2.add(new Student(4,"Jam",24));

         

          ListIterator<Student> li=l2.listIterator();

          while(li.hasNext()) {

                Student s1=li.next();

                System.out.println(s1.getName());

          }

          System.out.println();

          while(li.hasPrevious()) {

                Student s1=li.previous();

                System.out.println(s1.getName());

          }

         

          List<String> l3=new ArrayList<>();

          l3.add("Ram");

          l3.add("Sam");

          l3.add("Tam");

          ListIterator<String> lt=l3.listIterator();

          while(lt.hasNext()) {

                String s1=lt.next();

                lt.set(s1+"mmm");

          }

          while(lt.hasPrevious()) {

                String s1=lt.previous();

                System.out.println(s1);

          }

         

          Vector<Integer> v=new Vector<>();

              v.add(1);

              v.add(2);

              v.add(3);

              System.out.println(v); //[1,2,3]

              Enumeration e=v.elements();

              while(e.hasMoreElements()) {

                             System.out.println(e.nextElement());

              }

              }

}


Handson

 

1. Write a Java program to read all the player information from the user and display the player name and their cap number sorted based on their cap number (descending order). The contact details consist of player name, skill and cap number. Use Collections.sort() method for sorting.

 

Create a main class "Main.java"

Create Player class with below private  attributes

 

 

playerName - String

 

skill - String

 

capNumber - Long

 

Add appropriate getter and setter methods for Player class

Include a constructor for Player class with the arguments player name, skill and cap number

Implement Comparable interface and implement the method compareTo() to perform sorting based on cap number

 

Input and Output Format:

First input corresponds to the number of players and followed by each player's information.

Refer sample input and output for formatting specifications.

 

[All text in bold corresponds to input and the rest corresponds to output]

Sample Input/Output :

Enter number of players:

2

Enter player 1 detail

Enter Name

Suresh Raina

Enter Skill

Batsman

Enter Cap Number

265

Enter player 2 detail

Enter Name

Virat Kohli

Enter Skill

Batsman

Enter Cap Number

268

Player list after sorting by cap number in descending order

Virat Kohli-268

Suresh Raina-265

 

 

2.Comparator - no of matches player

 

Write a Java program to get the team name and number of matches played by the team from the user and display a report with team name and number of matches sorted based on the number of matches in ascending order. Use Collection.sort() method to perform the sorting in your main class. Send the Comparator object as second argument to the sort method to use this comparator for sorting.

 

Create a main class " Main.java"

Create a class named Team with the following private member variables / attributes,

name - String

numberOfMatches - Long

Include a constructor accepting Team name and number of matches as arguments

Add appropriate getter and setter methods for Team class

 

Create TeamComparator implementing Comparator interface

Implement compare method to compare two team objects based on their number of matches played.

 

Input and Output Format:

First input corresponds to the number of teams and followed by each team information.

Refer sample input and output for formatting specifications.

 

[All text in bold corresponds to input and the rest corresponds to output]

Sample Input/Output :

Enter number of teams:

3

Enter team 1 detail

Enter Name

Chennai super Kings

Enter number of matches

132

Enter team 2 detail

Enter Name

Royal Challengers Bangalore

Enter number of matches

139

Enter team 3 detail

Enter Name

Delhi Daredevils

Enter number of matches

131

Team list after sort by number of matches

131

132

139

 

 

 

Collections class

     - contain static methods/algorithm that support util package

 

Methods

1. static int binarySearch(List l,int val) - search any elet in list

2. static void copy(List dest,List src)

3. static List nCopies(int val,Object o) - create an immutable list with  list of values

4. static boolean disjoint(List l1,List l2) - return true if there is no common elt

5. static List emptyList() - create an immutable list

6. static Set emptySet() - create an immutable set

7. static Map emptyMap() - create an immutable map

8. static void fill(List l, Object o) - fill the list with particular value

9. static int frequency(List l, Object o) - return how many times an elt occur in the list

10. static boolean replaceAll(List l,Object oldval, Object newval)

11. static Object max(List l) - find max elt

12. static Object min(List l) - find min elt

13. static void reverse(List l)

14. static void shuffle(List l) - randomly shuffle elt

15. static List singletonList(Object o) - create list with single elt

16. static Set singleton(Object o)

17. static Map singletonMap(Object k, Object v)

18. static void sort(List l)

19. static void sort(List l,Comparator c)

20. static void swap(List l, int oldindex, int newindex)

21. static List synchronizedList(List l)

22. static Set synchronizedSet(Set s)

23. static Map synchronizedMap(Map m)

24. static List unmodifiableList(List l)

25. static Set unmodifiableSet(Set s)

26. static Map unmodifiableMap(Map m)

 

public class Main {

              public static void main(String...args) {

       List<Integer> l1=new ArrayList<>();

       l1.add(3);

       l1.add(5);

       l1.add(6);

       l1.add(7);

       l1.add(9);

       System.out.println(Collections.binarySearch(l1, 6)); //2

      

       List<String> l2=new ArrayList<>();

       l2.add("one");

       l2.add("two");

       l2.add("three");

       List<String> l3=new ArrayList<>();

       l3.add("four");

       l3.add("five");

       l3.add("six");

       //l3.add("seven");

      

       System.out.println(Collections.disjoint(l2, l3));  //true

       Collections.copy(l3, l2);

       System.out.println(l2);  //[one,two,three]

       System.out.println(l3);  //[one,two,three]

       System.out.println(Collections.disjoint(l2, l3)); //false

       

       List l4=Collections.nCopies(3, "Hello");

       System.out.println(l4); //[Hello,Hello,Hello]

       //l4.add("Hi");

       //System.out.println(l4); //UnsupportedOperationException

      

       List l5=Collections.emptyList();

       System.out.println(l5);  //[]

       //l5.add("Hi");

      // System.out.println(l5);  //exception

      

       System.out.println(Collections.frequency(l4, "Hello"));  //3

       Collections.fill(l3,"Hi");

       System.out.println(l3); //[Hi,Hi,Hi]

       Collections.replaceAll(l3, "Hi", "He");

       System.out.println(l3);  //[He,He,He]

      

       List<String> l6=new ArrayList<>();

       l6.add("Hii");

       l6.add("Hi");

       l6.add("Hiiii");

       l6.add("Hi Good monring");

       Collections.replaceAll(l6, "Hi", "He");

       System.out.println(l6);  //[Hii,He,Hiiii,Hi Good morning]

      

       List<Integer> l7=new ArrayList<>();

       l7.add(8);

       l7.add(-20);

       l7.add(-8);

       l7.add(20);

       System.out.println(l7);  //[8,-20,-8,20]

      

      Collections.reverse(l7);

      System.out.println(l7);  //[20,-8,-20,8]

      System.out.println(Collections.max(l7));  //20

      System.out.println(Collections.min(l7)); //-20

     

      Collections.shuffle(l7);

      System.out.println(l7);  //random order

      Collections.sort(l7); //ascending order

      System.out.println(l7); //[-20,-8,8,20]

 

      Collections.sort(l7,Comparator.reverseOrder()); //descending order

      System.out.println(l7); //[20,8,-8,-20]

     

      Collections.swap(l7, 0, 3);

      System.out.println(l7); //[20,-8,8,-20]

     

      l7=Collections.singletonList(23);

      System.out.println(l7); //[23]

      //l7.add(24);

     // System.out.println(l7);  //exception

     

      List l8=Collections.synchronizedList(l6);

      System.out.println(l8);  //threadsafe

     

      List l9=Collections.unmodifiableList(l2);

      System.out.println(l9);  //[one,two,three] - immutable

      l9.add("Hello");

      System.out.println(l9); //exception

              }

}

 

Arrays class

    - used to perform operation on any datatype array

 

Methods

1. static List asList(int[] a) - convert int array to List

2. static void fill(int[] a, int val) - fill all elts of array with val

3. static void fill(int[] a,int start,int end,int val) - fill elt with val from start to end-1

4. static void sort(int[] a) - sort all elts of array

5. static void sort(int[] a, int start,int end) - sort elts from start to end

6. static boolean equals(int[] a1,int[] a2)

7. static int binarySearch(int[] a,int val)

 

public class Main {

              public static void main(String...args) {

        Integer a[]=new Integer[10];

        for(int i=0;i<10;i++) {

              a[i]=i*-3;

        }

        for(int a1:a)

              System.out.println(a1);

       

        List<Integer> l=Arrays.asList(a);

        System.out.println(l); // [0,-3,-6,-9,-12,-15,-18,-21,-24,-27]

       

        Arrays.sort(a); //[-27,-24,-21,-18,-15,-12,-9,-6,-3,0]

        System.out.println(Arrays.binarySearch(a, -15)); //4

       

        //If value is not present it returns negative value based on -(index)-1

        //[-27,-24,-21,-18,-15,-12,-10,-9,-6,-3,0] = -(6)-1

        System.out.println(Arrays.binarySearch(a, -10)); //-7

        //[-27,-24,-22,-21,-18,-15,-12,-10,-9,-6,-3,0] = -(2)-1

        System.out.println(Arrays.binarySearch(a, -22));  //-3

       

        Arrays.sort(a); //[-27,-24,-21,-18,-15,-12,-9,-6,-3,0]

        Arrays.fill(a,2,5,-1); //start to end-1 by -1

          //[-27,-24,-1,-1,-1,-12,-9,-6,-3,0]

        Arrays.sort(a,2,5); //[-27,-24,-12,-1,-1,-1,-9,-6,-3,0]

        Arrays.sort(a); //[-27,-24,-12,-9,-6,-3,-1,-1,-1,0]

              }

}

 

- If we want to sort the elts of List interface, we have to use Collections.sort(List l)

- If we want to sort the elts of Set interface, we have to use TreeSet class

- If it is numbers then it will sorted in ascending order and String means it will sorted in alphabetical order

 

Comparable and Comparator interface

     - If ur List or Set interface contains collection of user defined object like Employee, Student, Player etc, now we want to sort based on their properties rather than sorting its reference

 

List<Employee> l=new ArrayList<>();

empid,ename,salary,age - properties

 

Comparable interface                                      Comparator interface

1. provides single sorting sequence         1. provides multiple sorting

(ie) we can do sorting based on             sequence (ie) we can do sorting

only property either by empid               based on empid and name and salary

or ename or salary or age                   age

 

2. present in java.lang.*                   2. present in java.util.*

 

3. int compareTo(Object o)                 3. int compare(Object o1,Object o2)

 

4. We do sorting using                     4. We do sorting using

Collections.sort(List l) for             Collections.sort(List l,Comparator c)

List intf and TreeSet class for          for List intf and

Set intf                                 TreeSet(Comparator c) for Set intf

 

 

public class Student implements Comparable<Student> {

   private Integer stuId;

   private String name;

   private Integer age;

public Integer getStuId() {

              return stuId;

}

public void setStuId(Integer stuId) {

              this.stuId = stuId;

}

public String getName() {

              return name;

}

public void setName(String name) {

              this.name = name;

}

public Integer getAge() {

              return age;

}

public void setAge(Integer age) {

              this.age = age;

}

public Student(Integer stuId, String name, Integer age) {

              super();

              this.stuId = stuId;

              this.name = name;

              this.age = age;

}

public Student() {

              super();

              // TODO Auto-generated constructor stub

}

@Override

public int compareTo(Student o) {

              // TODO Auto-generated method stub

              return name.compareTo(o.name);

}

/*@Override

public int compareTo(Student o) {

              if(age==o.age)

                 return 0;

              else if(age>o.age)

                             return 1;

              else

                             return -1;

}*/

@Override

public String toString() {

              return "Student [stuId=" + stuId + ", name=" + name + ", age=" + age + "]";

}

  

}

 

public class Employee {

              Integer eId;

                 String name;

                  Integer age;

              public Integer getEId() {

                             return eId;

              }

              public void setEId(Integer eId) {

                             this.eId = eId;

              }

             

              public String getName() {

                             return name;

              }

              public void setName(String name) {

                             this.name = name;

              }

              public Integer getAge() {

                             return age;

              }

              public void setAge(Integer age) {

                             this.age = age;

              }

              public Employee(Integer eId, String name, Integer age) {

                             super();

                             this.eId = eId;

                             this.name = name;

                             this.age = age;

              }

              public Employee() {

                             super();

                             // TODO Auto-generated constructor stub

              }

              @Override

              public String toString() {

                             return "Employee [eId=" + eId + ", name=" + name + ", age=" + age + "]";

              }

             

             

                

}

 

 

public class AgeComparator implements Comparator<Employee> {

 

              @Override

              public int compare(Employee o1, Employee o2) {

                             if(o1.age==o2.age)

                                return 0;

                             else if(o1.age>o2.age)

                                           return 1;

                             else

                                           return -1;

              }

 

}

 

 

public class NameComparator implements Comparator<Employee>{

 

              @Override

              public int compare(Employee o1, Employee o2) {

                             return o1.name.compareTo(o2.name);

              }

 

}

 

public class Main {

              public static void main(String...args) {

        List<Integer> l1=new ArrayList<>();

        l1.add(4);

        l1.add(2);

        l1.add(5);

        l1.add(1);

        l1.add(6);

        System.out.println(l1);  //[4,2,5,1,6]

        Collections.sort(l1);

        System.out.println(l1);  //[1,2,4,5,6]

        Collections.sort(l1,Comparator.reverseOrder());

        System.out.println(l1);  //[6,5,4,2,1]

       

        TreeSet<String> ts=new TreeSet<>();

        ts.add("H");

        ts.add("B");

        ts.add("E");

        ts.add("A");

        System.out.println(ts); //[A,B,E,H]

        TreeSet ts1=(TreeSet) ts.descendingSet();

        System.out.println(ts1); //[H,E,B,A]

       

        List<Student> l2=new ArrayList<>();

       l2.add(new Student(103,"Ram",24));

        l2.add(new Student(101,"Sam",20));

        l2.add(new Student(104,"Raj",21));

        l2.add(new Student(100,"Tam",23));

        l2.add(new Student(102,"Jam",19));

       

        Collections.sort(l2);  //internally calls compareTo

        for(Student s1:l2)

              System.out.println(s1);

       

        System.out.println();

        TreeSet<Student> ts2=new TreeSet<>();

        ts2.add(new Student(103,"Ram",24));

        ts2.add(new Student(101,"Sam",20));

        ts2.add(new Student(104,"Raj",21));

        ts2.add(new Student(100,"Tam",23));

        ts2.add(new Student(102,"Jam",19));

        for(Student s1:ts2)

              System.out.println(s1);

       

        List<Employee> l3=new ArrayList<>();

        l3.add(new Employee(103,"Ram",24));

        l3.add(new Employee(101,"Sam",20));

        l3.add(new Employee(104,"Raj",21));

        l3.add(new Employee(100,"Tam",23));

        l3.add(new Employee(102,"Jam",19));

       

        Collections.sort(l3,new AgeComparator());

        for(Employee e1:l3)

              System.out.println(e1.getAge());

       

        System.out.println();

        Collections.sort(l3,new NameComparator());

        for(Employee e1:l3)

              System.out.println(e1.getName());

       

        System.out.println();

        TreeSet<Employee> ts3=new TreeSet<>(new AgeComparator());

        ts3.add(new Employee(103,"Ram",24));

        ts3.add(new Employee(101,"Sam",20));

        ts3.add(new Employee(104,"Raj",21));

        ts3.add(new Employee(100,"Tam",23));

        ts3.add(new Employee(102,"Jam",19));

        for(Employee e1:ts3)

              System.out.println(e1);

              }

}

 

Map interface

      - used to store collection of object but in the form of unique key value pair

      - Map is unordered

 

Methods

1. void put(Object k,Object v) - insert single key value pair

2. void putAll(Map m) - store multiple key value pair

3. Object putIfAbsent(Object k,Object v) - if specified key is not associated with the value then it associates the key with given value and returns null

4. boolean containsKey(Object k)

5. boolean containsValue(Object v)

6. Object get(Object k) - if we provide the key, it will return value associated with that key

7. Object getOrDefault(Object k,Object defaultvalue)

8. Object remove(Object k) - if we provide the key, it will remove value associated with that key

9. boolean remove(Object k,Object v)

10. Object replace(Object k,Object v)

11. boolean replace(Object k, Object oldval, Object newval)

12. boolean isEmpty()

13. int size()

14. Set entrySet()

15. Set keySet()

 

Map.Entry interface

    - used to describe key and value separately

Methods

1. Object getKey()

2. Object getValue()

3. Object setValue(Object k)

 

SortedMap interface

      - used to sort the elements of Map interface

Methods

1. Object firstKey()

2. Object lastKey()

3. SortedMap subMap(Object start,Object end) - start to end-1

4. SortedMap headMap(Object k)

5. SortedMap tailMap(Object k)


Consider given data model,

 



Use static initializer to create ProductList, OrderList and CustomerList which contains sample Product, Order and Customer

 

Solve the following questions using Stream API

 

Obtain a list of products belongs to category “Books” with price > 100
Obtain a list of order with products belong to category “Baby”
Obtain a list of product with category = “Toys” and then apply 10% discount
Get the cheapest products of “Books” category
Get the 3 most recent placed order
Obtain a collection of statistic figures (i.e. sum, average, max, min, count) for all products of category “Books”
 

 

 

Streams API

 -The Stream API in Java is a powerful feature introduced in Java 8. It allows you to process collections of objects in a declarative and functional style.
    - contains collection of objects from some sources(Array,List,Set) and process them sequentially

    - Collection framework also stores collection of objects and we can manipulate the object, but streams are only used for processing the data and we cant manipulate the data

    - present in java.util.stream.* package

    - 2 types of streams - finite(fixed number of values) and infinite(unlimited) stream

    - 2 types of operation

1. Intermediate operation - return stream itself - optional operation - we can chain multiple intermediate operation

   - filter(), map(), flatMap(), sorted(), peek(), distinct(), limit(), skip()

 

2. Terminal operation - It will traverse into the newly generated stream and return single value - mandatory operation - we cant chain terminal operation

   - toArray(), forEach(), count(), min(), max(), reduce(), collect(),anyMatch(), allMatch(), noneMatch(), findFirst()

 

3 steps

Creation of Stream - Intermediate operation - Terminal Operation

   - If we perform terminal operation then that stream is completely closed, so when we perform any other operation on closed stream then we will get IllegalStateException

 

1. Creation of Stream - Finite stream - 2 ways

1. stream() - used to generate a stream from some source (ie) array or list or set

 

String s[]=new String[]{"one","two","three"};

Stream<String> s1=s.stream();

 

List<String> l1=new ArrayList<>();

l1.add("Ram");

l1.add("Sam");

l1.add("Raj");

Stream<String> s2=l1.stream();

 

2. of() - used to create our own stream

 

Stream<Integer> st= Stream.of(1,2,3,4,5);

 

filter() - intermediate - used to filter the data based on some condition

 

reduce() - terminal - used to group the data into single value

         - Optional reduce(BinaryOperator)

         - Integer reduce(int initialvalue, BinaryOperator)

         - Stream reduce(int initialvalue, BinaryOperator b1, BinaryOperator b2)

 

public class Main {

              public static void main(String[] args) {

                  List<String> l1=new ArrayList<>();

                  l1.add("Ram");

                  l1.add("Sam");

                  l1.add("Raj");

                  l1.add("Tam");

                  l1.add("Tim");

                  l1.add("Ram");

                  l1.add("John");

                  l1.add("Jack");

                  System.out.println(l1.size()); //8

                 

                  Stream<String> s1=l1.stream();

                  Stream<String> s2=s1.distinct();

                  long c=s2.count();

                  System.out.println(c); //7

                 

                  long c1=l1.stream().distinct().count();

                  System.out.println(c1); //7,

                 

                  boolean b1=l1.stream().distinct().anyMatch((e)->e.startsWith("R"));

                  System.out.println(b1);  //true

                 

                  boolean b2=l1.stream().distinct().allMatch((e)->e.startsWith("R"));

                  System.out.println(b2);  //false

                 

                  boolean b3=l1.stream().distinct().noneMatch((e)->e.startsWith("Z"));

                  System.out.println(b3);  //true

                 

                  List<Student> l2=new ArrayList<>();

                  l2.add(new Student(23,"PK"));

                  l2.add(new Student(26,"KK"));

                  l2.add(new Student(23,"MK"));

                  l2.add(new Student(21,"SK"));

                  l2.add(new Student(40,"RK"));

                  l2.add(new Student(30,"BK"));

                  l2.add(new Student(29,"DK"));

                  l2.add(new Student(28,"GK"));

                  l2.add(new Student(33,"TK"));

                 

                  Stream<Student> st=l2.stream().filter((a1)->a1.getId()>25);

                  st.forEach(System.out::println);

                 

                  Optional opt=Stream.of(3,5,6).reduce((a,b)->a*b);

                  System.out.println(opt.get());  //90

                 

                  Integer i=Stream.of(3,5,6).reduce(2, (a,b)->a*b);

                  System.out.println(i);  //180

                 

                  Optional<String> opt1=Stream.of("lion","ape","tiger").min((c11,c21)->c11.length()-c21.length());

                  System.out.println(opt1.get());  //ape

              }

}

 

map() - intermediate

      - takes one Function functional interface as an argument and returns a stream consisting of result generated by applying the passed function to each element

      - used for data transformation

 

collect() - terminal - used to collect the data as list or set

 

Collectors.toList()

Collectors.toSet()

Collectors.toMap(Function f1,Function f2)

Collectors.joining()

Collectors.counting()

Collectors.toCollection(Supplier s)

Collectors.partitioningBy() - used to split the list into 2 parts based on true and false

      - partitioningBy(predicate)

      - partitioningBy(predicate,Collector)

Collectors.groupingBy() - group the stream of elements under some condition

      - groupingBy(Function)

      - groupingBy(Function,Collector)

      - groupingBy(Function,Comparator,Collector)

 

flatMap() - intermediate

          - takes one Function functional interface as an argument and returns a new stream and that stream is copied to another stream which will return the value

          - used for data transformation + flatenning

 

public class Main {

              public static void main(String[] args) {

                 Integer a[]=new Integer[] {1,2,3,4,5};

                 List<Integer> l1=Arrays.asList(a);

                

                 //JDK10

                 //List<Integer> l2=List.of(1,2,3,4,5); //create immutable list

                

                 List<Integer> l2=l1.stream().map((e)->e*3).collect(Collectors.toList());

                 l2.forEach(System.out::println); //3,6,9,12,15

                

                 List<Integer> l3=l1.stream().flatMap((e1)->Stream.of(e1*2)).collect(Collectors.toList());

                  l3.forEach(System.out::println);//2,4,6,8,10

                 

                 String s1=Stream.of("one","two","three").collect(Collectors.joining("-"));

                 System.out.println(s1);  //one-two-three

                

                 long c=Stream.of("one","two","three").collect(Collectors.counting());

                 System.out.println(c);  //3

                

                List<String> l4=Stream.of("lions","tigers","bears","toads","toads")

                     .filter((s)->s.startsWith("t")).collect(Collectors.toList());

                l4.forEach(System.out::println); //tigers,toads,toads

               

                Set<String> l5=Stream.of("lions","tigers","bears","toads","toads")

                                    .filter((s)->s.startsWith("t")).collect(Collectors.toSet());

                               l5.forEach(System.out::println); //tigers,toads

                              

                               TreeSet<String> ts=Stream.of("lions","tigers","bears","toads","toads","tadpole")

                     .filter((s)->s.startsWith("t")).collect(Collectors.toCollection(TreeSet::new));

                     System.out.println(ts); //[tadpole,tigers,toads]

                    

                   Map<String,Integer>  m1=Stream.of("lions","tigers","bears","toads")

                       .collect(Collectors.toMap(k1->k1, String::length));

                   m1.forEach((k,v)->System.out.println("Key = "+k+" Value = "+v));

                  

                   Map<Boolean,List<String>> m2=Stream.of("lions","tigers","bears","toads","toads","tadpole")

                         .collect(Collectors.partitioningBy((a1)->a1.length()<=5));

                   System.out.println(m2);

                  

                   Map<Boolean,Set<String>> m3=Stream.of("lions","tigers","bears","toads","toads","tadpole")

                                        .collect(Collectors.partitioningBy((a1)->a1.length()<=5,Collectors.toSet()));

                                  System.out.println(m3);

                                                

                              Map<Integer,List<String>> m4=Stream.of("lions","tigers","bears","lions","ape")

                                         .collect(Collectors.groupingBy((e)->e.length()));

                             System.out.println(m4);

                            

                              Map<Integer,Set<String>> m5=Stream.of("lions","tigers","bears","lions","ape")

                                         .collect(Collectors.groupingBy((e)->e.length(),Collectors.toSet()));

                             System.out.println(m5);

                            

                              TreeMap<Integer,Set<String>> m6=Stream.of("lions","tigers","bears","lions","ape")

                                         .collect(Collectors.groupingBy((e)->e.length(),TreeMap::new,Collectors.toSet()));

                             System.out.println(m6);

                                 

              }

}

 

sorted() - intermediate - used to sort the elt

 

public class Main {

              public static void main(String[] args) {

                 List<String> l1=List.of("9","A","z","1","B","4","e","f");

                

                 List<String> l21=l1.stream().sorted().collect(Collectors.toList()); //asc order

                 System.out.println(l21);

                 List<String> l3=l1.stream().sorted(Comparator.reverseOrder()).collect(Collectors.toList()); //desc order

                 System.out.println(l3);

                

                 List<Student> l2=new ArrayList<>();

                  l2.add(new Student(23,"PK"));

                  l2.add(new Student(26,"KK"));

                  l2.add(new Student(23,"MK"));

                  l2.add(new Student(21,"SK"));

                  l2.add(new Student(40,"RK"));

                  l2.add(new Student(30,"BK"));

                  l2.add(new Student(29,"DK"));

                  l2.add(new Student(28,"GK"));

                  l2.add(new Student(33,"TK"));

                 

                  //comparaingInt(), comparaingDouble(), comparaingLong()

                  List<Student> l4=l2.stream().sorted(Comparator.comparingInt(Student::getId))

                                                        .collect(Collectors.toList());

                  l4.forEach(System.out::println);

                  System.out.println();

                  List<Student> l5=l2.stream().sorted(Comparator.comparingInt(Student::getId).reversed())

                           .collect(Collectors.toList());

         l5.forEach(System.out::println);

         System.out.println();

         List<Student> l6=l2.stream().sorted(Comparator.comparing(Student::getName))

                           .collect(Collectors.toList());

          l6.forEach(System.out::println);

          System.out.println();

          List<Student> l7=l2.stream().sorted(Comparator.comparing(Student::getName).reversed())

                           .collect(Collectors.toList());

           l7.forEach(System.out::println);

              }

}

 

Other ways to create stream

1. builder() - create finite stream

2. generate() - create infinite stream

3. iterate() - create infinite stream

 

Create streams based on primitive datatype

1. IntStream - create stream of int values

2. DoubleStream - create stream of double values

3. LongStream - create stream of long values

 

From JDK1.9

takeWhile() - if stream does not match the predicate, it will discard the rest of stream

dropWhile() - if stream does not match the predicate, it will print the rest of stream

 

public class Main {

              public static void main(String[] args) {

                 Stream<String> s1=Stream.<String>builder().add("Ram").add("Sam").add("Raj").build();

                 s1.forEach(System.out::println);

                

                 Stream<String> s2=Stream.generate(()->"hello").limit(5);

                 s2.forEach(System.out::println);

                

                 Stream<Integer> s3=Stream.iterate(2, (i)->i*2).skip(3).limit(5);

                 s3.forEach(System.out::println);

                

                 IntStream i1=IntStream.range(1,6);  //start to end-1

                 i1.forEach(System.out::println);  //1 2 3 4 5

                

                 IntStream i2=IntStream.rangeClosed(1,6);  //start to end

                 i2.forEach(System.out::println);  //1 2 3 4 5 6

                

                 IntStream i3="abcd".chars();

                 i3.forEach(System.out::println);  //97 98 99 100

                

                 Random r=new Random();

                 DoubleStream d1=r.doubles(5);

                 d1.forEach(System.out::println);

                

                 List<Student> l2=new ArrayList<>();

                  l2.add(new Student(23,"PK"));

                  l2.add(new Student(26,"KK"));

                  l2.add(new Student(23,"MK"));

                  l2.add(new Student(21,"SK"));

                  l2.add(new Student(40,"RK"));

                  l2.add(new Student(30,"BK"));

                  l2.add(new Student(29,"DK"));

                  l2.add(new Student(28,"GK"));

                  l2.add(new Student(33,"TK"));

                

                  IntStream i5=l2.stream().mapToInt(Student::getId);

                  i5.forEach(System.out::println);

                 

                 OptionalInt op=l2.stream().mapToInt(Student::getId).max();

                 System.out.println(op.getAsInt());  //40

                

                 OptionalDouble op1=l2.stream().mapToDouble(Student::getId).average();

                 System.out.println(op1.getAsDouble());

                

                 //IntSummaryStatistics,DoubleSummaryStatistics, LongSummaryStatistics

                 IntSummaryStatistics in=l2.stream().collect(Collectors.summarizingInt(t->t.getId()));

                 System.out.println(in);

                 System.out.println(in.getAverage()+" "+in.getCount());

                

                 Stream.of(2,4,6,8,9,10,12).takeWhile(n->n%2==0).forEach(System.out::println);  //2 4 6 8

                 Stream.of(2,4,6,8,9,10,12).dropWhile(n->n%2==0).forEach(System.out::println); //9 10 12
                

              }

}



Handson

 

1.Display Date

 

Given a date in the form of string, write a program to convert the given string to date .

Include a class UserMainCode with a static method displayDate which accepts a string. In this method display the given string in date format yyyy-MM-dd. The return type is void.

 

Create a Class Main which would be used to accepts a string and call the static method present in UserMainCode.

 

Input and Output Format:

Input consists of a string.

Output consists of Date.

 

Refer sample output for formatting specifications.

 

Sample Input 1:

May 1, 2016

Sample Output 1:

2016-05-01

 

Sample Input 2:

March 21, 2016

Sample Output 2:

2016-03-21

 

 

2.Extract Date and time

 

Write a program to extract date and time from the input string which is in yyyy-MM-dd HH:mm:ss date format.

 

Include a class UserMainCode with a static method displayDateTime which accepts a string. In this method display date and time in the format as given in sample input and output . The return type is void.

 

Create a Class Main which would be used to accept string and call the static method present in UserMainCode.

 

Input and Output Format:

Input consists of a string.

Output should be in date format

 

Refer sample output for formatting specifications.

 

Sample Input :

 

Enter String in this format(yyyy-MM-DD HH:mm:ss)

 

2016-07-14 09:00:02  

Sample Output :

 

07/14/2016, 9:00:02

 

 

3.Day Of The Year

 

Given a date, write a program to display day of the year.

Include a class UserMainCode with a static method displayDay which accepts a date. In this

method, display day in the format as given in sample input and output . The return type is void.?

?Input date Format is yyyy-MM-dd

 Create a Class Main which would be used to accept date and call the static method present in

UserMainCode.?

?

Input and Output Format:?

Input consists of a string.

Refer sample output for formatting specifications.

 

Sample Input :

2013-03-23

 

Sample Output :

Day of year: 82

 

 

4.Name Of the Day

 

 

Given a date in the date format, write a program to get the day of the corresponding date .

Include a class UserMainCode with a static method displayDay which accepts a date. In this method display the day of  given date . The return type is void.

 

Create a Class Main which would be used to accept a date and call the static method present in UserMainCode.

?Input date Format is yyyy-MM-dd 

Input and Output Format:

Input consists of a date.

Refer sample output for formatting specifications.

 

Sample Input 1:

2011-10-21

Sample Output 1:

Friday

 

Sample Input 2:

2011-07-11

Sample Output 2:

Monday

 

 

5.Difference between dates in month

 

Given a method with two date strings in yyyy-mm-dd format as input. Write code to find the difference between two dates in months.

 

Include a class UserMainCode with a static method getMonthDifference which accepts two date strings as input.

 

The return type of the output is an integer which returns the diffenece between two dates in months.

 

Create a class Main which would get the input and call the static method getMonthDifference present in the UserMainCode.

 

Input and Output Format:

Input consists of two date strings.

Format of date : yyyy-mm-dd.

 

Output is an integer.

Refer sample output for formatting specifications.

 

Sample Input 1:

2012-03-01

2012-04-16

Sample Output 1:

1

 

 

Sample Input 2:

2011-03-01

2012-04-16

Sample Output 2:

13
 

 

 

Before JDK1.8, Date class present in java.util.* package

 

1. Date class - print date and time

 

2. Calendar class - abstract class, used to extract useful info and date and time

 

3. GregorianCalendar class - concrete implementation of Calendar class, used to extract useful info and date and time

 

4. DateFormat class - abstract class, used for formating(convert date to string) and parsing(converting string to date), we can display date and time in different format - SHORT,LONG,MEDIUM,FULL - present in java.text.* pkg

 

5. SimpleDateFormat class - concrete implementation of DateFormat class, used for formating(convert date to string) and parsing(converting string to date), we can display date and time in different format -present in java.text.* pkg

 

public class Main {

              public static void main(String[] args)  {

                   Date d1=new Date();  //print current date and time

                   System.out.println(d1); //Fri Sep 29 13:03:05 IST 2023

                   Date d2=new Date(10000); //print date and time from Jan 1st 1970

                   System.out.println(d2);  //Thu Jan 01 05:30:10 IST 1970

                  

                   Calendar c=Calendar.getInstance(); //current date and time

                   System.out.println(c.get(Calendar.YEAR));

                   System.out.println(c.get(Calendar.MONTH));

                  

                   GregorianCalendar gc=new GregorianCalendar(); //current date and time

                   System.out.println(gc.get(Calendar.YEAR));

                   System.out.println(gc.get(Calendar.MONTH));

                   GregorianCalendar gc1=new GregorianCalendar(2000,10,20,13,23,24);

                   System.out.println(gc1.get(Calendar.HOUR));

                   System.out.println(gc1.get(Calendar.MINUTE));

                  

                   DateFormat df=DateFormat.getInstance(); //default short format

                   String s=df.format(d1);

                   System.out.println(s);

                   DateFormat df1=DateFormat.getDateInstance(DateFormat.LONG);

                   String s1=df1.format(d1);

                   System.out.println(s1);

                   DateFormat df2=DateFormat.getTimeInstance(DateFormat.MEDIUM);

                   String s2=df2.format(d1);

                   System.out.println(s2);

                   DateFormat df3=DateFormat.getDateTimeInstance(DateFormat.FULL,DateFormat.FULL); //default short format

                   String s3=df3.format(d1);

                   System.out.println(s3);

                  

                   String s4="10/03/2023";

                   SimpleDateFormat sdf=new SimpleDateFormat("dd/MM/yyyy");

                   try {

                            Date d3=sdf.parse(s4);

                            System.out.println(d3); //Fri Sep 29 13:23:04 IST 2023

                            SimpleDateFormat sdf1=new SimpleDateFormat("yyyy-MM-dd");

                            System.out.println(sdf1.format(d3));

                   }

                   catch(ParseException e) {

                             System.out.println(e);

                   }

              }

}


















1. int x; 
2. private int x=10; 
5. public static final int x=10


//3. public volatile int x=10; 
4. public transient int x=10; 

 



















 

Date API

    - Available from JDK1.8 onwards

    - present in java.time.* package

    - Date is immutable class where lower version of Date is not immuntable

 

class and interfaces

1. LocalDate class - print only date - yyyy-MM-dd

2. TemporalAdjuster interface - used to get extra info from date and time

3. LocalTime class - print only time

4. LocalDateTime class - print both date and time

5. Period class - used to find difference between 2 dates

6. Duration class - used to find difference between 2 time

7. DateTimeFormatter interface - used to display date and time in different format

 

public class Main {

              public static void main(String[] args)  {

                  LocalDate l1=LocalDate.now();  //current date

                  System.out.println(l1); //2023-09-29

                 

                  LocalDate l2=LocalDate.of(2000, 10,20); //create our own date

                  System.out.println(l2); //2000-10-20

                 

                  LocalDate l3=LocalDate.parse("2001-04-23"); //convert string to date

                  System.out.println(l3); //2001-04-23

                 

                  LocalDate l4=l3.plusMonths(2);

                  System.out.println(l4);

                  LocalDate l5=l4.plus(4, ChronoUnit.YEARS);

                  System.out.println(l5);

                 

                  LocalDate l6=l5.minusDays(100);

                  System.out.println(l6);

                  LocalDate l7=l6.minus(5, ChronoUnit.WEEKS);

                  System.out.println(l7);

                 

                  DayOfWeek d1=LocalDate.parse("2023-09-29").getDayOfWeek();

                  System.out.println(d1);  //Friday

                  int m=LocalDate.parse("2023-09-29").getDayOfMonth();

                  System.out.println(m);  //29

                  int y=LocalDate.parse("2023-09-29").getDayOfYear();

                  System.out.println(y); //272

                  int mon=LocalDate.parse("2023-09-29").getMonthValue();

                  System.out.println(mon); //9

                  System.out.println(l7.isLeapYear());

                 

                  boolean b1=LocalDate.parse("2023-09-29").isAfter(LocalDate.parse("2023-09-30"));

                  System.out.println(b1);  //false

                  boolean b2=LocalDate.parse("2023-09-29").isBefore(LocalDate.parse("2023-09-30"));

                  System.out.println(b1);  //true

                  boolean b3=LocalDate.parse("2023-09-29").isEqual(LocalDate.parse("2023-09-30"));

                  System.out.println(b1);  //false

                 

                  LocalDate l8=LocalDate.now().with(TemporalAdjusters.firstDayOfMonth());

                  System.out.println(l8);  //2023-09-01

                  LocalDate l9=LocalDate.now().with(TemporalAdjusters.lastDayOfMonth());

                  System.out.println(l9);

                  LocalDate l10=LocalDate.now().with(TemporalAdjusters.firstDayOfNextYear());

                  System.out.println(l10);

                  LocalDate l11=LocalDate.now().with(TemporalAdjusters.next(DayOfWeek.SATURDAY));

                  System.out.println(l11);  //2023-09-30

                  LocalDate l12=LocalDate.now().with(TemporalAdjusters.previous(DayOfWeek.THURSDAY));

                  System.out.println(l12); //2023-09-28

                 

                  LocalTime t1=LocalTime.now();

                  System.out.println(t1);

                  LocalTime t2=LocalTime.now(ZoneId.of("America/Chicago"));

                  System.out.println(t2);

                  LocalTime t3=LocalTime.of(9, 39);

                  System.out.println(t3);

                  LocalTime t4=LocalTime.parse("09:30");

                  System.out.println(t4);

                 

                  LocalTime t5=t4.plusMinutes(23);

                  System.out.println(t5);

                  LocalTime t6=t5.plus(4, ChronoUnit.HOURS);

                  System.out.println(t6);

                  LocalTime t7=t6.minusNanos(20000);

                  System.out.println(t7);

                  LocalTime t8=t7.minus(35, ChronoUnit.SECONDS);

                  System.out.println(t8);

                  System.out.println(LocalTime.MAX);

                  System.out.println(LocalTime.MIN);

                  System.out.println(LocalTime.MIDNIGHT);

                 

                  LocalDateTime ld1=LocalDateTime.now();

                  System.out.println(ld1); //2023-09-29T13:53:24

                  LocalDateTime ld2=LocalDateTime.of(LocalDate.now(), LocalTime.now());

                  System.out.println(ld2);

                  LocalDateTime ld3=LocalDateTime.parse("2023-09-29T13:53:24");

                  System.out.println(ld3);  //2023-09-29T13:53:24

                  System.out.println(ld3.toLocalDate());

                  System.out.println(ld3.toLocalTime());

                  System.out.println(LocalDateTime.MAX);

                  System.out.println(LocalDateTime.MIN);

                 

                  //convert JDK1.5 Date to JDK1.8 LocalDate

                  Date d11=new Date();

                  LocalDateTime ld4=LocalDateTime.ofInstant(d11.toInstant(), ZoneId.systemDefault());

                  System.out.println(ld4);

                 

                  //convert Calendar to JDK1.8 LocalDate

                  Calendar cal=Calendar.getInstance();

                  LocalDateTime ld5=LocalDateTime.ofInstant(cal.toInstant(), ZoneId.systemDefault());

                  System.out.println(ld5);

                 

                  LocalDate l13=LocalDate.now();

                  LocalDate l14=LocalDate.of(2023, 05, 20);

                  int diff1=Period.between(l13, l14).getDays();

                  System.out.println(diff1);

                 

                  int diff2=Period.between(l13, l14).getMonths();

                  System.out.println(diff2);

                 

                  long diff3=ChronoUnit.YEARS.between(l14, l2);

                  System.out.println(diff3);

                 

                  LocalTime t9=LocalTime.now();

                  LocalTime t10=LocalTime.of(9, 30);

                  long diff4=Duration.between(t9,t10).getSeconds();

                  System.out.println(diff4);

                  long diff5=Duration.between(t9,t10).toHours();

                  System.out.println(diff5);

                  long diff6=Duration.between(t9,t10).toMinutes();

                  System.out.println(diff6);

                  long diff7=ChronoUnit.NANOS.between(t9,t10);

                  System.out.println(diff7);

                 

                  LocalDateTime ld6=LocalDateTime.now();

                  String s1=ld6.format(DateTimeFormatter.ISO_DATE_TIME);

                  System.out.println(s1);

                  String s2=ld6.format(DateTimeFormatter.ofPattern("dd/MM/yyyy"));

                  System.out.println(s2);

                  String s3=ld6.format(DateTimeFormatter.ofLocalizedDate(FormatStyle.SHORT));

                  System.out.println(s3);

                  String s4=ld6.format(DateTimeFormatter.ofLocalizedTime(FormatStyle.LONG));

                  System.out.println(s4);

                  String s5=ld6.format(DateTimeFormatter.ofLocalizedDateTime(FormatStyle.MEDIUM,FormatStyle.FULL));

                 System.out.println(s5);

              }

}

 

Optional class

    - Object will contain memory reference or null reference, so if we access anything using null reference we get NullPointerException

    - To avoid NPE we have to write code to do the null check, so to avoid unpredictable NPE  we can go for Optional class

    - present in java.util.* package

 

Methods

1. static Optional empty() - return empty optional

2. static Optional of(T...t) - return an non empty optional, if value is null it return NPE

3. static Optional ofNullable(T...t) - return an non empty optional, if value is null it return empty optional

4. Object get() - return original value from Optional class

5. void ifPresent(Consumer) - if value is present it invokes related consumer

6. boolean isPresent() - return ture if value is present otherwise false

7. Object orElse(Object) - return the value if present otherwise return other value

8. Object orElseGet(Supplier) - return the value if present otherwise it invoke another logic and return the result

9. Object orElseThrow(Supplier) - return the value if present otherwise it will throw an exception

 

public class Main {

              public static void main(String[] args) throws Throwable  {

                  Optional o1=Optional.empty();

                  System.out.println(o1); //Optional.empty

                  Optional o2=Optional.of("John");

                  System.out.println(o2); //Optional[John]

                  //Optional o3=Optional.of(null);

                  //System.out.println(o3);  //NPE

                 

                  Optional o4=Optional.ofNullable("Jim");

                  System.out.println(o4); //Optional[Jim]

                  Optional o5=Optional.ofNullable(null);

                  System.out.println(o5);  //Optional.empty

                 

                  Optional o6=Optional.of("John");

                  System.out.println(o6); //Optional[John]

                  System.out.println(o6.get()); //John

                  o6.ifPresent(System.out::println); //John

                  System.out.println(o6.isPresent()); //true

                  Optional o7=Optional.empty();

                  System.out.println(o7.isPresent());  //false

                  o7.ifPresent(System.out::println);  //no output

                  System.out.println(o7.orElse("Johnny"));  //Johnny

                  System.out.println(o7.orElseGet(()->"Peter"));  //Peter

                  System.out.println(o7.orElseThrow(NullPointerException::new));

              }

}

 

3. Default and static methods in interface

        - Till JDK1.7, interface will contain only abstract method and public static final variables

        - From JDK1.8, apart from abstract method, interface can also contain default and static method

        - Without affecting the implemented classes, if we want to add any new methods inside the interface then we can go for default methods

        - If  my functionality is noway related with object(ie) static method, instead of defining inside the class we can define inside the interface

        - From JDK1.9, the interface will contain private and private static methods, if we have  common functionality inside default method and to avoid duplicate code, we can define those common functionality inside private method and access inside default method whenever needed

 

interface A {

              default void show() {

                             System.out.println("Inside A's show");

              }

}

interface B {

              default void show() {

                             System.out.println("Inside B's show");

              }

}

class Sample implements A,B {

 

              @Override

              public void show() {

                             //A.super.show();

                             B.super.show();

              }

             

}

public class Main {

              public static void main(String[] args) throws Throwable  {

                  Sample s=new Sample();

                  s.show();

              }

}

 

Interface member access

1. Accessible from default and private methods within interface

       constant variable = yes

       abstract method=yes

      another default method =yes

       private method=yes

       static method=yes

       private static method=yes

 

2. Accessible from static methods within interface

       constant variable = yes

       abstract method=NO

      another default method =NO

       private method=NO

       static method=yes

       private static method=yes

 

3. Accessible from instance methods by implementing interface

       constant variable = yes

       abstract method=yes

      another default method =yes

       private method=no

       static method=yes

       private static method=no

 

4. Accessible outside interface without implementing interface

       constant variable = yes

       abstract method=no

      another default method =no

       private method=no

       static method=yes

       private static method=no

 

interface MyInterface {

              //Till JDK1.7

              /*public static final*/ int CONSTANT=0;

              /*public abstract*/ int abstractMethod();

             

              //From JDK1.8

              /*public*/ default int defaultMethod() {

                             abstractMethod();

                             privateMethod();

                             staticMethod();

                             privateStaticMethod();

                             return CONSTANT;

              }

              /*public*/ static int staticMethod() {

                             privateStaticMethod();

                             return CONSTANT;

              }

             

              //From JDK1.9

              private int privateMethod() {

                             abstractMethod();

                             defaultMethod();

                             staticMethod();

                             privateStaticMethod();

                             return CONSTANT;

              }

              private static int privateStaticMethod() {

                            

              }

}

class Example implements MyInterface {

 

              @Override

              public int abstractMethod() {

                             defaultMethod();

                             MyInterface.staticMethod();

                             return CONSTANT;

              }

             

}

class Example1 {

              public int instanceMethod() {

                             MyInterface.staticMethod();

                             return MyInterface.CONSTANT;

              }

}

public class Main {

              public static void main(String[] args) throws Throwable  {

                 

              }

}

 

var keyword

    - Available from JDK10

    - used to infer datatype at runtime

        var a=10;

    - used only inside constructor or methods or loops or compound block          

Rules

1. var cant declare without initial value

2. var can be declared in first line and initialized in second line

3. var cannot be initialized with null value without a type

4. var is not permitted in multiple variable declaration

5. var cannot be used to initialize an array

6. var is reserved type name but not reserved keyword, so we can use var as an identifier except for class, interface ,enum

7. var in lambda expr - you cant mix var and non-var  parameters

 

interface MyInterface {

              void add(int a,int b);

}

class Var {

              Var() {

                             var var="var";  //correct

              }

              public void var() { //correct

                             Var var=new Var(); //correct

              }

}

/*class var{  //error

 

}

interface var { //error

             

}

enum var {  //error

             

}*/

public class Main {

              Main(){

                             var a1="hello";

              }

              {

                             var a2=10;

                             a2=11;

              }

              public static void main(String[] args) {

                   var size=1;

                   for(var i=0;i<10;i++) {

                             

                   }

                   //var x;  //error

                   var x

                        =3.14f;

                   var x1=23.34;

                   x1=x;

                   var y

                        ="hello";

                   //var z=null; //error

                   var z=(String)null;

                   var z1="hello";

                   z1=null;

                  

                   int a=5,b=6;

                  // var a1=5,b1=9; //error

                  

                  // var a1[]= {1,2,4}; //error

                  

                   MyInterface m1=(var a1,var b1)->System.out.println(a1+b1);  //correct

                   MyInterface m2=(int a1,var b1)->System.out.println(a1+b1);  //error

              }
}


















Enum
    - It is type of class that mainly stores constants or fixed set of values
    - It implicitly abstract class, by default it is final so we cant inherit and it can implemented by a interface
 
interface A {
              void add();
}
enum Day1 implements A {
    SUNDAY,MONDAY,TUESDAY,WEDNESDAY,THURSDAY,FRIDAY,SATURDAY;
 
              @Override
              public void add() {
             
              }
}
/*enum Day2 extends Day1{
             
}*/
enum Day {
     SUNDAY,MONDAY,TUESDAY,WEDNESDAY,THURSDAY,FRIDAY,SATURDAY
}
public class Main {
              public static void main(String[] args)  {
       Day d1=Day.TUESDAY;
       System.out.println(d1);  //TUESDAY
      
       Day d2=d1;
       System.out.println(d2); //TUESDAY
       //Day d3=10; //error
      
       Day d3=Day.valueOf("MONDAY");
       System.out.println(d3); //MONDAY
       //Day d4=Day.valueOf("monday");
       //System.out.println(d4); //IllegalArgumentException
       System.out.println(d1==d2); //true
       System.out.println(d1.equals(d2)); //true
       System.out.println(Day.FRIDAY);  //FRIDAY
      
       for(Day d:Day.values()) {
                 System.out.println(d.name()+" "+d.ordinal());
       }
              }
}
 
Rules
1. enum values are declared first, then only we can define anything
 
enum Day {
              //int a=10;  //error
    SUNDAY,MONDAY,TUESDAY,WEDNESDAY,THURSDAY,FRIDAY,SATURDAY;
              int s=10; //correct
}
 
2. If we want to define anything after enum values then it should end with semicolon
 
3. A non final enum method can be overridden by any enum value
 
enum Day {
              SUNDAY {
                             public void printTemp() {
                                           System.out.println("55");
                             }
              },
              MONDAY,
              TUESDAY,
              WEDNESDAY,
              THURSDAY,
              FRIDAY,
              SATURDAY;
              private String temperature;
             
              public void printTemp() {
                             System.out.println("65");
              }
}
public class Main {
              public static void main(String[] args)  {
       Day d1=Day.TUESDAY;
       d1.printTemp(); //65
       Day.SUNDAY.printTemp(); //55
              }
}
 
4. If we have abstract method then it should be implemented by all enum value
 
enum Day {
              SUNDAY {
                             public void printTemp() {
                                           System.out.println("55");
                             }
              },
              MONDAY {
                             @Override
                             public void printTemp() {
                                           System.out.println("50");
                             }
              },
              TUESDAY {
                             @Override
                             public void printTemp() {
                                           System.out.println("45");
                             }
              },
              WEDNESDAY {
                             @Override
                             public void printTemp() {
                                           System.out.println("40");
                             }
              },
              THURSDAY {
                             @Override
                             public void printTemp() {
                                           System.out.println("35");
                             }
              },
              FRIDAY {
                             @Override
                             public void printTemp() {
                                           System.out.println("25");
                             }
              },
              SATURDAY {
                             @Override
                             public void printTemp() {
                                           System.out.println("36");
                             }
              };
              private String temperature;
             
              public abstract void printTemp();
}
public class Main {
              public static void main(String[] args)  {
       Day d1=Day.TUESDAY;
       d1.printTemp(); //45
       Day.SUNDAY.printTemp(); //55
              }
}
 
5. Constructor is implicitly private, called once in the beginning to create enum value
 
enum Day {
              SUNDAY("High") {
                             public void printTemp() {
                                           System.out.println("55");
                             }
              },
              MONDAY("Low") {
                             @Override
                             public void printTemp() {
                                           System.out.println("50");
                             }
              },
              TUESDAY("High") {
                             @Override
                             public void printTemp() {
                                           System.out.println("45");
                             }
              },
              WEDNESDAY("Moderate") {
                             @Override
                             public void printTemp() {
                                           System.out.println("40");
                             }
              },
              THURSDAY("Low") {
                             @Override
                             public void printTemp() {
                                           System.out.println("35");
                             }
              },
              FRIDAY("High") {
                             @Override
                             public void printTemp() {
                                           System.out.println("25");
                             }
              },
              SATURDAY("Low") {
                             @Override
                             public void printTemp() {
                                           System.out.println("36");
                             }
              };
              String temperature;
             
              /*private*/ Day(String temperature){
                             this.temperature=temperature;
              }
             
              public abstract void printTemp();
}
public class Main {
              public static void main(String[] args)  {
       Day d1=Day.TUESDAY;
       d1.printTemp(); //45
       Day.SUNDAY.printTemp(); //55
      
       for(Day d:Day.values()) {
                 System.out.println(d+" "+d.temperature);
       }
              }
}
 
enum Marks {
              ENGLISH(67),
              MATHS(100),
              SCIENCE(99),
              SOCIAL(100),
              LANGUAGE(89);
              int mark;
    Marks(int mark){
              this.mark=mark;
    }
}
public class Main1 {
 
              public static void main(String[] args) {
                             for(Marks m:Marks.values()) {
                                           System.out.println(m+" "+m.mark);
                             }
              }
 
}
 
6. Enum can also used in switch case
 
public class Main {
              public static void main(String[] args)  {
     Day1 d1=Day1.FRIDAY;
     switch(d1) {
     case SUNDAY:
               System.out.println("High");
               break;
     case MONDAY:
               System.out.println("Low");
               break;
     case TUESDAY:
               System.out.println("Moderate");
               break;
     default:
               System.out.println("No comments");
               break;
     }
              }
}
 

























("Athens","Greece","Europe",37.59,"N",23.44,"E"),("Atlanta","United States","North America",33.45,"N",84.23,"W"),("Dallas","United States","North America",32.47,"N",96.47,"W");








("Nashville","United States","North America",36.09,"N",86.46,"W"),
("Victoria","Canada","North America",48.25,"N",123.21,"W"),
("Peterborough","Canada","North America",44.18,"N",79.18,"W"),


("Vancouver","Canada","North America","49.18,"N",123.04,"W"),
("Toledo","United States","North America",41.39,"N",83.82,"W"),
("Warsaw","Poland","Europe",52.15,"N",21.00,"E"),
("Lima	Peru","South America",12.03,"S",77.03,"W"),
("Rio De Janeiro","Brazil","South America",22.43,"S",43.13,"W"),
("Santiago',"Chile","South America",33.27,"S",70.40,"W"),
101861703005


("Bogota","Colombia","South America",04.36,"N",74.05,"W"),
("Buenos Aires","Argentina","South America",34.36,"S",58.28,"W"),

("Quito","Ecuador","South America",00.13,"S",78.30,"W"),
("Caracas","Venezuela","South America",10.30,"N",66.56,"W"),

("Madras","India","Asia",28.36,"N",77.12,"E"),
("Bombay","India","Asia",18.58,"N",72.50,"E"),
("Manchester","England","Europe",51.30,"N",0.0,"null"),

Moscow	Russia	Europe	55.45	N	37.35	E
Paris	France	Europe	48.52	N	2.20	E
Shenyang	China	Asia	41.48	N	123.27	E
Cairo	Egypt	Africa	30.03	N	31.15	E
Tripoli	Lybia	Africa	32.54	N	13.11	E
Beijing	China	Asia	39.56	N	116.24	E
Rome	Italy	Europe	41.54	N	12.29	E
Tokyo	Japan	Asia	35.42	N	139.46	E
Sydney	Australia	Australia	33.52	S	151.13	E
Sparta	Greece	Europe	37.05	N	22.27	E
Madrid	Spain	Europe	40.24	N	3.41	W



















