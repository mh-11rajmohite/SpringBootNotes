DAY 22
====================================
Handson

1. Create springboot appl to insert student details into the db using commandline runner

 

 

@Value

1. Injecting properties one by one

2. Loose binding/loose grammar is not supported (ie) attribute name should be matching

3. Support SpEL (${})

4. Validation of properties is not supported

4. Support only scalar datatype

 

@ConfigurationProperties

1. Bulk injection of properties

2. Loose binding/loose grammar is  supported (ie) no need to match attribute name (ie) special char or cases

3. Not support SpEL

4. Validation of properties is supported

5. Supports all datatypes as well as objects

 

mail.properties

#scalar datatype

mail.to=abc@gmail.com

mail.from=xyz@gamil.com

mail.age=25

mail.firstname=Ramu

mail.lastname=kumar

 

#complex datatype

mail.cc=uvw@gmail.com,efh@gmail.com

mail.bcc=mno@gmail.com,pqr@gmail.com

 

#Nested datatype

mail.credential.username=ram

mail.credential.password=abcde

 

 

To do validation

 

<dependency>

                                           <groupId>org.hibernate.validator</groupId>

                                           <artifactId>hibernate-validator</artifactId>

                                           <version>6.0.5.Final</version>

                             </dependency>

                             <dependency>

                                           <groupId>javax.validation</groupId>

                                           <artifactId>validation-api</artifactId>

                                           <version>2.0.0.Final</version>

                             </dependency>

 

@Validated - to do validating the properties in properties file

@Valid - to do validation for nested class properties

 

@Configuration

@PropertySource("classpath:mail.properties")

@ConfigurationProperties(prefix="mail")

@Data

@Validated

public class MailProps {

              @NotBlank

    private String to;

              @NotBlank

    private String from;

              @Min(value=20)

              @Max(value=40)

    private Integer age;

              private String FIRSTNAME;

   

    private String[] cc;

    private List<String> bcc;

   

    @Valid

    private Credential credential=new Credential();

   

    @Data

    public class Credential {

              @NotBlank

              private String username;

              @Size(max=8,min=4)

              private String password;

    }

}

 

 

@RestController

@Log4j2

public class StudentController {

             

              @Value("${student.id}")

              private Integer id;

             

              @Value("${student.mark}")

              private Integer mark;

             

              @Value("${mail.lastname}")

              private String lname;

             

              @Autowired

              StudentProps stuProp;

             

              @Autowired

              MailProps mail;

 

              @GetMapping("/student")

              public String getStudentInfo() {

                             return id+" "+mark+" "+stuProp.getFirstname()+" "+stuProp.getAddress();

              }

             

              @GetMapping("/mail")

              public String mailInfo() {

                             return mail.getFrom()+" "+mail.getCc()+" "+mail.getBcc()+" "+mail.getCredential().getUsername()+" "+mail.getFIRSTNAME();

              }

}

 

Springboot Interceptors

     - used to intercept client request and response

     - Interceptors are similar to Filters(servlet), but interceptors are applied to the request that are sending to the controller prg

     - We have to implement HandlerInterceptor interface - 3 methods

1. preHandle() - perform any operation before sending request to controller

 2. postHandle() - perform any operation before sending response to client

3. afterCompletion() - perform any operation after completing request and response

 

@RestController

@Log4j2

public class EmployeeController {

 

              @GetMapping("/emp")

              public String getEmployeeInfo() {

                             log.info("Inside EmployeeController");

                             return "Employee are working";

              }

}

 

@Component

@Log4j2

public class TimerInterceptor implements HandlerInterceptor {

             

    @Override

              public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler)

                                           throws Exception {

                             log.info("Inside preHandle");

                             request.setAttribute("startTime", System.currentTimeMillis());

                             return true;

              }

   

    @Override

    public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler,

                             ModelAndView modelAndView) throws Exception {

              log.info("Inside postHandle");

    }

   

    @Override

    public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex)

                             throws Exception {

              log.info("Inside afterCompletion");

              long totalTime=System.currentTimeMillis()-(long)request.getAttribute("startTime");

              System.out.println("Total time taken is "+totalTime);

    }

}

 

 

@Configuration

public class EmployeeConfig implements WebMvcConfigurer {

             

              @Autowired

              TimerInterceptor timerInterceptor;

 

              @Override

              public void addInterceptors(InterceptorRegistry registry) {

                  //registry.addInterceptor(timerInterceptor); //this interceptor will be invoked for all controller prg

              registry.addInterceptor(timerInterceptor).addPathPatterns("/emp","/mail");

              }

}

 

JDBC

JPA

 

Spring Data JPA

    - Used to persist data into database

    - It is a library that adds an extra layer of abstraction on top of JPA providers

 

JPA providers - vendors that provide the implementation of JPA specification like Hibernate, iBatis, Toplink etc

 

JPA specification - provides mapping of entity class with column of database table using @Entity, @Table, @Id etc

 

3 layers

1. Spring Data JPA - Create JPA Repository - 2 interface

a. JpaRepository<Entityclassname, datatype of PK> interface - used to perform CRUD and batch operation

    - T getById(int id) - deprecated

    - T getOne(int id) - deprecated

    - T getReferenceById(int id) - fetch single object

    - List<T> findAll() - return multiple object

    - T saveAndFlush(T t) - store single object into db

    - T saveAllAndFlush(Iterable) - store multiple object into db

    - void deleteAllByIdInBatch(Iterable)

    - void deleteAllInBatch()

b. JpaSpecificationExecutor<Entityclassname> interface - used to retrieve data

based on some condition

 

2. Spring data commons layer - 3 interface

a. Repository<Entityclassname, datatype of PK> interface - marker interface

b. CrudRepository<Entityclassname, datatype of PK> interface - used to perform Crud operation

    - T save(T t)- store single object

    - T saveAll(Iterable) - store multiple object

    - Optional findById(int id) - return single object

    - Iterable findAll() - fetch all object

    - boolean existsById(int id)

    - void deleteById(int id) - delete single object based on id

    - void delete(T t) - delete single object

    - void deleteAll()

c. PagingAndSortingRepsitory<Entityclassname, datatype of PK> interface - used for paging and sorting purpose

 

3. JPA providers - vendors that provide the implementation of JPA specification like Hibernate, iBatis, Toplink etc

 

Repository interface

  extends

CrudRepository interface

  extends

PagingAndSortingRepository interface

  extends

JpaRepository interface

 

1. Create spring boot project with spring data jpa, mysql, lombok dependency

  

2. Configure db info in application.properties

spring.datasource.url=jdbc:mysql://localhost:3306/jpa

spring.datasource.username=root

spring.datasource.password=root

spring.datasource.driver-class-name=com.mysql.jdbc.Driver

spring.jpa.show-sql = true

spring.jpa.hibernate.ddl-auto = update

#dialect will generate the query based on particular db

spring.jpa.database-platform=org.hibernate.dialect.MySQL5Dialect

 

3. Create entity class

 

@Entity

@Table(name="empl2023")

@Data

@NoArgsConstructor

@AllArgsConstructor

public class Employee {

  @Id

  private Integer id;

  private String name;

  private String gender;

  private String email;

  private String dept;

  private Double salary;

}

 

4. Create repository interface

 

public interface EmployeeRepository extends JpaRepository<Employee, Integer> {

 

}

 

5.

 

@SpringBootApplication

public class SpringDataApplication implements CommandLineRunner{

             

              @Autowired

              EmployeeRepository empRepo;

 

              public static void main(String[] args) {

                             SpringApplication.run(SpringDataApplication.class, args);

              }

 

              @Override

              public void run(String... args) throws Exception {

                             //insertEmployee();

                             //fetchEmployee(104);

                             //fetchAllEmployee();

                             //updateEmployee(103);

                             deleteEmployee(103);

              }

 

              private void deleteEmployee(int i) {

                             if(empRepo.existsById(i)) {

                                           //Employee e=empRepo.findById(i).get();

                                           //empRepo.delete(e);

                                           empRepo.deleteById(i);

                             }

              }

 

              private void updateEmployee(int i) {

                             if(empRepo.existsById(i)) {

                                           Employee e=empRepo.findById(i).get();

                                           e.setSalary(60000.0);

                                           empRepo.save(e);

                             }

              }

 

              private void fetchAllEmployee() {

                             List<Employee> l=empRepo.findAll();

                             l.forEach(System.out::println);

              }

 

              private void fetchEmployee(int i) {

                             Optional opt=empRepo.findById(i);

                             System.out.println(opt.get());

              }

 

              private void insertEmployee() {

                             /*Employee e1=new Employee(100,"Ram","male",ram@gmail.com,"HR",20000.0);

                             empRepo.save(e1);*/

                            

                             List<Employee> l1=new ArrayList<>();

                             Employee e1=new Employee(101,"Sam","male",sam@gmail.com,"Sales",25000.0);

                             l1.add(e1);

                             Employee e2=new Employee(102,"Saj","male",saj@gmail.com,"IT",35000.0);

                             l1.add(e2);

                             Employee e3=new Employee(103,"Lim","female",lim@gmail.com,"HR",15000.0);

                             l1.add(e3);

                             Employee e4=new Employee(104,"Amy","female",amy@gmail.com,"Sales",36000.0);

                             l1.add(e4);

                             Employee e5=new Employee(105,"Adam","male",adam@gmail.com,"IT",45000.0);

                             l1.add(e5);

                             Employee e6=new Employee(106,"Tam","male",Tam@gmail.com,"Sales",55000.0);

                             l1.add(e6);

                             empRepo.saveAll(l1);

              }

 

}
==============================================
DAY 23

1. Create java maven project with 2 dependency junit-jupiter, mockito dependency

 

<dependencies>

            <dependency>

            <groupId>org.junit.jupiter</groupId>

            <artifactId>junit-jupiter</artifactId>

            <version>5.5.2</version>

            <scope>test</scope>

        </dependency>

        <dependency>

            <groupId>org.mockito</groupId>

            <artifactId>mockito-junit-jupiter</artifactId>

            <version>3.2.4</version>

            <scope>test</scope>

        </dependency>

    </dependencies>

 

2. Create model class

 

public class Book {

              private String bookId;

              private String title;

              private int price;

              private LocalDate publishedDate;

        //getter,setters and constructor

}

 

3. Create repo interface

 

public interface BookRepository {

              Book findBookByBookId(String bookId);

              void save(Book book);

}

 

4. Create service class

 

public class BookService {

             

              private BookRepository bookRepository;

             

              public BookService(BookRepository bookRepository) {

                             this.bookRepository = bookRepository;

              }

             

              public int calculateTotalCost(List<String> bookIds) {

                             int total = 0;

                             for(String bookId : bookIds){

                                           Book book = bookRepository.findBookByBookId(bookId);

                                           total = total + book.getPrice();

                             }

                             return total;

              }

             

              public void addBook(Book book) {

                             bookRepository.save(book);

              }

             

             

}

 

 

@RunWith(MockitoJunitRunner.class) - Junit4 will support annotation based mockito

 

@ExtendWith(MockitoExtension.class) - Junit5 will support annotation based mockito

 

controller - service - repostiory - database

 

@InjectMocks - It tells which class is under test - prg that is communicate with external dependency or class annotated @Mock

 

@Mock - create a mock implementation for the class u need or whatever external implementation we need to mock

 

1. Stubbing of methods

       - One of the primary benefit of mockito is ability to return a provided response when a specific method is called on mock dependency, so we need to tell mockito what to return as response of that method

       - The process of writing how a given mock method should behave or return that is called stubbing

 

2 ways

1. using mockito static method when()+thenReturn() - "when" any specific method is called on mock object, "thenReturn" some preconfigured value

2. using mockito static method doReturn()+when() - "doReturn" some preconfigured value, "when" specific method is called on mock object

3. test void methods, then we have to use doNothing()+when()

 

- Mockito uses equals() while matching argument during stubbing, in case response is not stubbed for a method, then default value are returned when called

    primitive datatype - return 0

    boolean - return false

    any object and array - return null

    any collection - return empty collection

 

@ExtendWith(MockitoExtension.class)

public class BookServiceTest {

 

              @InjectMocks

              BookService bookService;

              @Mock

              BookRepository bookRepo;

             

              @Test

              public void testCalculateTotalCost() {

                             List<String> bookIds=new ArrayList<>();

                             bookIds.add("1234");

                             bookIds.add("1235");

                            

                             Book book1=new Book("1234","Mockito",500,LocalDate.now());

                             Book book2=new Book("1235","Junit5",400,LocalDate.now());

                            

                             //when+thenReturn

                            /*when(bookRepo.findBookByBookId("1234")).thenReturn(book1);

                            when(bookRepo.findBookByBookId("1235")).thenReturn(book2);

                             int cost=bookService.calculateTotalCost(bookIds);

                             assertEquals(900,cost);*/

                            

                             //doReturn+when

                            /*doReturn(book1).when(bookRepo).findBookByBookId("1234");

                            doReturn(book2).when(bookRepo).findBookByBookId("1235");

                             int cost=bookService.calculateTotalCost(bookIds);

                             assertEquals(900,cost); */

                            

                             //In case we didnt give proper parenethesis we get UnfinishedStubbingException

                            /*doReturn(book1).when(bookRepo.findBookByBookId("1234"));

                            doReturn(book2).when(bookRepo.findBookByBookId("1235"));

                             int cost=bookService.calculateTotalCost(bookIds);

                             assertEquals(900,cost); */

                            

                            //when(bookRepo.findBookByBookId("1234")).thenReturn(book1);

                            //when(bookRepo.findBookByBookId("1234")).thenReturn(book1);

                             /*when(bookRepo.findBookByBookId("1234"))

                                     .thenReturn(book1)

                                     .thenReturn(book1);

                             int cost=bookService.calculateTotalCost(bookIds);

                             assertEquals(1000,cost);*/

              }

             

              @Test

              public void testAddBook() {

                             Book b1=new Book("1235","Junit5",400,LocalDate.now());

                             doNothing().when(bookRepo).save(b1);

                             bookService.addBook(b1);

              }

}

 

2. Exception Handling in Mockito

        - Exception covers our -ve scenario

 

- If we test exception for non void methods then we use when()+thenThrow()

- If we test exception for void methods then we use doThrow()+when()

 

1. Create model class

 

public class Book {

              private String bookId;

              private String title;

              private int price;

              private LocalDate publishedDate;

        //getter,setters and constructor

}

 

2. Create repo

 

public interface BookRepository {

              List<Book> findAllBooks() throws SQLException;

              void save(Book book) throws SQLException;

}

 

3. Create service class

 

public class BookService {

             

              private BookRepository bookRepository;

             

              public BookService(BookRepository bookRepository) {

                             this.bookRepository = bookRepository;

              }

             

              public int getTotalPriceOfBooks() {

                             List<Book> books = null;

                             try {

                                           books = bookRepository.findAllBooks();

                             } catch (SQLException e) {

                                           // log exception

                                           throw new DatabaseReadException("Unable to read from database due to - " + e.getMessage());

                             }

                             int totalPrice = 0;

                             for(Book book : books){

                                           totalPrice = totalPrice + book.getPrice();

                             }

                             return totalPrice;

              }

             

              public void addBook(Book book){

                             try {

                                           bookRepository.save(book);

                             } catch (SQLException e) {

                                           // log exception

                                           throw new DatabaseWriteException("Unable to write in database due to - " + e.getMessage());

                             }

              }

}

 

4. Create DatabaseReadException

 

public class DatabaseReadException extends RuntimeException {

              public DatabaseReadException(String message) {

                             super(message);

              }

}

 

5. Create DatabaseWriteException

 

public class DatabaseWriteException extends RuntimeException {

              public DatabaseWriteException(String message) {

                             super(message);

              }

}

 

@ExtendWith(MockitoExtension.class)

public class BookServiceTest {

 

              @InjectMocks

              BookService bookService;

              @Mock

              BookRepository bookRepo;

             

              @Test  //non void method

              public void testGetTotalPriceOfBooks() throws SQLException{

                            //when(bookRepo.findAllBooks()).thenThrow(SQLException.class);

                             //when(bookRepo.findAllBooks()).thenThrow(new SQLException("Database is not found");

                            //given(bookRepo.findAllBooks()).willThrow(SQLException.class);

                             assertThrows(DatabaseReadException.class,()->bookService.getTotalPriceOfBooks());

              }

             

              @Test  //void method

              public void testAddBook() throws SQLException{

                             Book b1=new Book("1234","Mockito",500,LocalDate.now());

                             //doThrow(SQLException.class).when(bookRepo).save(b1);

                             //doThrow(new SQLException("Database is not found")).when(bookRepo).save(b1);

                             assertThrows(DatabaseWriteException.class,()->bookService.addBook(b1));

              }

}

 

3. Behaviour verification

      - One of the primary benefit of mockito is that when mock object is created it remembers all operations performed on it

      - used to verify that mock method was called by system or not

      - using verify()

 

1. create model class

public class Book {

              private String bookId;

              private String title;

              private int price;

              private LocalDate publishedDate;

}

 

public class BookRequest {

              private String title;

              private int price;

              private LocalDate publishedDate;

}

 

 

2. create repo

public interface BookRepository {

              void save(Book book);

              Book findBookById(String bookId);

}

 

3. create service class

 

public class BookService {

             

              private BookRepository bookRepository;

             

              public BookService(BookRepository bookRepository) {

                             this.bookRepository = bookRepository;

              }

             

              public void addBook(Book book) {

                             if(book.getPrice() <= 500){

                                           return;

                             }

                             bookRepository.save(book);

              }

             

              public void updatePrice(String bookId, int updatedPrice){

                             if(bookId==null) {

                                           return;

                             }

                             Book book = bookRepository.findBookById(bookId);

                             book.setPrice(updatedPrice);

                             bookRepository.save(book);

              }

}

 

@ExtendWith(MockitoExtension.class)

public class BookServiceTest {

 

              @InjectMocks

              BookService bookService;

              @Mock

              BookRepository bookRepo;

             

              //To verify bookRepo is invoked or not, since it is an mock object

              @Test

              public void testAddBook() {

                             Book b1=new Book("1234","Mockito",600,LocalDate.now());

                             bookService.addBook(b1);

                             verify(bookRepo).save(b1);

              }

             

              //To verify number of invocations of  mock method, if book price is <= 500 then it wont invoke save()

              @Test

              public void testAddBook1()  {

                             Book b1=new Book("1234","Mockito",500,LocalDate.now());

                             bookService.addBook(b1);

                             verify(bookRepo,times(0)).save(b1);

              }

             

              @Test

              public void testAddBook2()  {

                             Book b1=new Book("1234","Mockito",600,LocalDate.now());

                             Book b2=new Book("1235","Mockito",700,LocalDate.now());

                             bookService.addBook(b1);

                             bookService.addBook(b2);

                             //verify(bookRepo,times(2)).save(b1);

                             //verify(bookRepo,atLeast(4)).save(b1);

                             //verify(bookRepo,atMost(2)).save(b1);

                             //verify(bookRepo,atMostOnce()).save(b1);

                             verify(bookRepo,atLeastOnce()).save(b1);

              }

             

              //Here price is 500, so it wont invoke save(), previously we checked using times(0)

              //instead we can use never()

              @Test

              public void testAddBook3()  {

                             Book b1=new Book("1234","Mockito",500,LocalDate.now());

                             bookService.addBook(b1);

                             verify(bookRepo,never()).save(b1);

              }

             

              @Test

              public void testUpdatePrice() {

                             Book b1=new Book("1234","Mockito",700,LocalDate.now());

                             bookService.updatePrice("1234", 200);

                             verify(bookRepo).save(b1);

              }

             

              //Verify no interaction with mock object

              @Test

              public void testUpdatePrice1() {

                             bookService.updatePrice(null, 200);

                             verifyNoInteractions(bookRepo);

              }

             

              //verify no unexpected interaction

              @Test

              public void testUpdatePrice2() {

                             Book b1=new Book("1234","Mockito",700,LocalDate.now());

                             when(bookRepo.findBookById("1234")).thenReturn(b1);

                             bookService.updatePrice("1234",700);

                             verifyNoMoreInteractions(bookRepo);

              }

             

              //To call mock object in order, if we change the order the test case failed

              @Test

              public void testUpdatePrice3() {

                             Book b1=new Book("1234","Mockito",700,LocalDate.now());

                             when(bookRepo.findBookById("1234")).thenReturn(b1);

                             bookService.updatePrice("1234",800);

                             InOrder o=Mockito.inOrder(bookRepo);

                             o.verify(bookRepo).findBookById("1234");

                             o.verify(bookRepo).save(b1);

              }

}

 

4. ArgumentCaptor

      - we can capture the arguments passed to mock methods

 

1. Create model class

public class Book {

              private String bookId;

              private String title;

              private int price;

              private LocalDate publishedDate;

}

 

public class BookRequest {

              private String title;

              private int price;

              private LocalDate publishedDate;

}

 

2. Create repo

public interface BookRepository {

              void save(Book book);

}

 

3. Create service class

 

public class BookService {

             

              private BookRepository bookRepository;

             

              public BookService(BookRepository bookRepository) {

                             this.bookRepository = bookRepository;

              }

 

             

              public void addBook(BookRequest bookRequest) {

                             Book book = new Book();

                             book.setTitle(bookRequest.getTitle());

                             book.setPrice(bookRequest.getPrice());

                             book.setPublishedDate(bookRequest.getPublishedDate());

                             bookRepository.save(book);

              }

             

}

 

@ExtendWith(MockitoExtension.class)

public class BookServiceTest {

 

              @InjectMocks

              BookService bookService;

              @Mock

              BookRepository bookRepo;

              @Captor

              ArgumentCaptor<Book> bookCaptor;

             

              @Test

              public void testAddBook() {

                             BookRequest req=new BookRequest("Mockito",500,LocalDate.now());

                             bookService.addBook(req);

                             verify(bookRepo).save(bookCaptor.capture());

                             Book book=bookCaptor.getValue();

                             assertEquals("Mockito",book.getTitle());

              }

 

}

 

5. ArgumentMatchers

       - used to pass some dynamice values to the arguments, it is like wildcard where instead of specific input we can specify the range or type of input

       - ArgumentMatchers should be provide for all arguments, either u provide all arg with argument matcher or provide fixed value, dont use combination, then testcase failed

       - Argumentmatchers can be used only with when() or with verify(), u cant call argument matches while calling the method

       - Specific type of argument matchers - anyBoolean(), anyByte(), anyChar(), anyInt(), anyFloat(), anyDouble(), anyLong(), anyShort(), anyString()

       - Collection type argument matchers - anyList(), anySet(), anyMap()

       - String type argument matcher - matches(string), startsWith(string), contains(string), endsWith(String)

 

3 methods

1. any() - any object or null

   any(Class c)

   anyVararg() - any vararg

 

1. Create model class

public class Book {

              private String bookId;

              private String title;

              private int price;

              private LocalDate publishedDate;

              private boolean isDigital;

             

}

 

2. Create repo

public interface BookRepository {

              void save(Book book);

              Book findBookById(String bookId);

              Book findBookByTitleAndPublishedDate(String title, LocalDate localDate);

              Book findBookByTitleAndPriceAndIsDigital(String title, int price, boolean isDigital);

              void saveAll(List<Book> books);

}

 

3. Create service class

 

public class BookService {

             

              private BookRepository bookRepository;

             

              public BookService(BookRepository bookRepository) {

                             this.bookRepository = bookRepository;

              }

             

             

              public void updatePrice(String bookId, int updatedPrice){

                             Book book = bookRepository.findBookById(bookId);

                             book.setPrice(updatedPrice);

                             bookRepository.save(book);

              }

             

              public Book getBookByTitleAndPublishedDate(String title, LocalDate localDate) {

                             return bookRepository.findBookByTitleAndPublishedDate(title, localDate);

              }

             

              public Book getBookByTitleAndPriceAndIsDigital(String title, int price, boolean isDigital) {

                             return bookRepository.findBookByTitleAndPriceAndIsDigital(title, price, isDigital);

              }

             

              public void addBooks(List<Book> books) {

                             bookRepository.saveAll(books);

              }

}

 

@ExtendWith(MockitoExtension.class)

public class BookServiceTest {

 

              @InjectMocks

              BookService bookService;

              @Mock

              BookRepository bookRepo;

             

              @Test

              public void testUpdatePrice() {

                             Book b1=new Book("1234","Mockito",500,LocalDate.now());

                             //when(bookRepo.findBookById(any())).thenReturn(b1);

                            when(bookRepo.findBookById(any(String.class))).thenReturn(b1);

                             bookService.updatePrice("1234",200);

                             verify(bookRepo).save(b1);

              }

 

              //Invalid use of Argument           Matchers

              @Test

              public void testInvalidArgumentMatchers() {

                             Book b1=new Book("1234","Mockito",500,LocalDate.now());

              //when(bookRepo.findBookByTitleAndPublishedDate("Mockito",any())).thenReturn(b1);  //wrong

                  Book b2=bookService.getBookByTitleAndPublishedDate("Mockito",any());  //wrong

              }

             

              @Test

              public void testSpecificMatchers() {

                             Book b1=new Book("1234","Mockito",500,LocalDate.now());

                            when(bookRepo.findBookByTitleAndPriceAndIsDigital(anyString(), anyInt(), anyBoolean())).thenReturn(b1);

                             Book b2=bookService.getBookByTitleAndPriceAndIsDigital("Mockito",600, false);

                             assertEquals("Mockito",b2.getTitle());

              }

             

              @Test

              public  void testCollectionMatchers() {

                             List<Book> books=new ArrayList<>();

                             Book b1=new Book("1234","Mockito",500,LocalDate.now());

                             books.add(b1);

                             bookService.addBooks(books);

                             verify(bookRepo).saveAll(anyList());

              }

             

              @Test

              public void testStringMatchers() {

                             Book b1=new Book("1234","Mockito in action",500,LocalDate.now());

                  when(bookRepo.findBookByTitleAndPriceAndIsDigital(contains("action"), anyInt(), anyBoolean())).thenReturn(b1);

                             Book b2=bookService.getBookByTitleAndPriceAndIsDigital("Mockito in action", 700, true);

                             assertEquals("Mockito in action",b2.getTitle());

              }

}

===========================================================

DAY 24


1. Create springboot project with spring web, spring data jpa, h2 db, lombok, dev tool

 

2. Configure db in application.properties

 

spring.datasource.url=jdbc:h2:mem:testdb

spring.datasource.driverClassName=org.h2.Driver

spring.datasource.username=sa

spring.datasource.password=

spring.jpa.show-sql=true

spring.jpa.hibernate.ddl-auto= update

 

spring.h2.console.enabled=true

# default path: h2-console

spring.h2.console.path=/h2-ui

spring.mvc.pathmatch.matching-strategy = ANT_PATH_MATCHER

server.port=2000

 

3. Create entity class

 

@Entity

@Data

@AllArgsConstructor

@NoArgsConstructor

public class Movie {

   @Id

   private Integer id;

   private String name;

   private String language;

   private String type;

   private Integer rating;

}

 

4. Create repository

 

public interface MovieRepository extends JpaRepository<Movie, Integer> {

   List<Movie> findByType(String type);

}

 

5. Create controller

@RestController

@RequestMapping("/api")

public class MovieController {

             

              @Autowired

              MovieService movieService;

 

              @PostMapping("/movie")

              public ResponseEntity<Movie> createMovie(@RequestBody Movie movie){

                             try {

                                           Movie savedMovie=movieService.createMovie(movie);

                                           return new ResponseEntity<Movie>(savedMovie,HttpStatus.CREATED);

                             }	

                             catch(Exception e) {

                                           return new ResponseEntity<>(null,HttpStatus.INTERNAL_SERVER_ERROR);

                             }

              }

             

              @GetMapping("/movie")

              public ResponseEntity<List<Movie>> getAllMovies() {

                             try {

                                           List<Movie> list=new ArrayList<>();

                                           movieService.getAllMovies().forEach(list::add);

                                           if(list.isEmpty()) {

                                                          return new ResponseEntity<>(HttpStatus.NO_CONTENT);

                                           }

                                           return new ResponseEntity<>(list,HttpStatus.CREATED);

                             }

                             catch(Exception e) {

                                           return new ResponseEntity<>(null, HttpStatus.INTERNAL_SERVER_ERROR);

                             }

              }

             

              @GetMapping("/movie/{movid}")

              public ResponseEntity<Movie> getMovieById(@PathVariable("movid") Integer id){

                             Movie movie=movieService.getMovieById(id);

                             if(movie!=null) {

                                           return new ResponseEntity<>(movie,HttpStatus.OK);

                             } else {

                                           return new ResponseEntity<>(HttpStatus.NOT_FOUND);

                             }

              }

             

              @GetMapping("/movie/byType")

              public ResponseEntity<List<Movie>> getMovieByType(@RequestParam("type")String type){

        List<Movie> list=movieService.getMovieByType(type);

        if(list.isEmpty()) {

              return new ResponseEntity<>(HttpStatus.NOT_FOUND);

        }

        return new ResponseEntity<>(list,HttpStatus.OK);

              }

             

}

 

----Create Service

 

@Service

public class MovieService {

             

              @Autowired

              MovieRepository movieRepo;

 

              public Movie createMovie(Movie movie) {

                             return movieRepo.save(new Movie(movie.getId(),movie.getName(),movie.getLanguage(),movie.getType(),movie.getRating()));

              }

             

              public List<Movie> getAllMovies(){

                             return movieRepo.findAll();

              }

             

              public Movie getMovieById(Integer id) {

                             return movieRepo.findById(id).get();

              }

             

              public List<Movie> getMovieByType(String type){

                             return movieRepo.findByType(type);

              }

}

 

 

 

6. To give request we have to use either PostMan or Swagger it is a documentation tool where it will document all the request and provides an UI

 

<dependency>

                                           <groupId>io.springfox</groupId>

                                           <artifactId>springfox-swagger2</artifactId>

                                           <version>2.9.2</version>

                             </dependency>

                             <dependency>

                                           <groupId>io.springfox</groupId>

                                           <artifactId>springfox-swagger-ui</artifactId>

                                           <version>2.9.2</version>

                             </dependency>

 

@Configuration

@EnableSwagger2

public class SwaggerConfig {

 

              @Bean

              public Docket movieApi() {

                             return new Docket(DocumentationType.SWAGGER_2)

                                                               .select()

                                                               .apis(RequestHandlerSelectors.basePackage("com.pack"))

                                                               .paths(regex("/api/movie.*"))

                                                               .build();
	
              }

}

 

7. To open swagger

http://localhost:2000/swagger-ui.html

 

8. To open h2 console

http://localhost:2000/h2-ui

 

spring-boot-starter-test - used to write testcases in spring boot - comes with junit5, mocktio, hamcrest

 

<dependency>

                                           <groupId>org.springframework.boot</groupId>

                                           <artifactId>spring-boot-starter-test</artifactId>

                                           <scope>test</scope>

                             </dependency>

 

 

@WebMvcTest - loads only the web layer which includes security, filter, interceptors etc for handling request/response. It is mainly used to write test for @Controller or @RestController

 

MockMvc class is a part of Spring MVC framework which helps in testing controller by explicitly starting server, which will be used along with Springboot WebMvcTest class to execute Junit testcases which test controller prg

 

@MockBean - to add mock object to spring boot appl

 

@Builder - used to build the object - Builder design pattern

 

import static org.hamcrest.CoreMatchers.is;

import static org.mockito.ArgumentMatchers.any;

import static org.mockito.BDDMockito.given;

import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.post;

import static org.springframework.test.web.servlet.result.MockMvcResultHandlers.print;

import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.jsonPath;

import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.status;

import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.get;

import java.util.ArrayList;

import java.util.List;

 

import org.junit.jupiter.api.Test;

import org.junit.jupiter.api.extension.ExtendWith;

import org.mockito.junit.jupiter.MockitoExtension;

import org.springframework.beans.factory.annotation.Autowired;

import org.springframework.boot.test.autoconfigure.web.servlet.WebMvcTest;

import org.springframework.boot.test.mock.mockito.MockBean;

import org.springframework.http.MediaType;

import org.springframework.mock.web.MockHttpServletResponse;

import org.springframework.test.web.servlet.MockMvc;

import org.springframework.test.web.servlet.ResultActions;

import static org.junit.jupiter.api.Assertions.*;

import com.fasterxml.jackson.databind.ObjectMapper;

import com.pack.SpringbootMockito.controller.MovieController;

import com.pack.SpringbootMockito.entity.Movie;

import com.pack.SpringbootMockito.service.MovieService;

 

@ExtendWith(MockitoExtension.class)

@WebMvcTest(value=MovieController.class)

public class TestMovieController {

 

              @Autowired

              MockMvc mockMvc;

             

              @MockBean

              MovieService movieService;

             

              @Autowired

              ObjectMapper objectMapper;

             

              @Test

              public void testCreateMovie() throws Exception {

                             Movie movie=Movie.builder().id(1000).name("Robert")

                                                          .language("Tamil").rating(4).type("action").build();

                             given(movieService.createMovie(any(Movie.class)))

                                  .willAnswer((inv)->movie);

                             ResultActions response=mockMvc.perform(post("/api/movie")

                                                            .contentType(MediaType.APPLICATION_JSON)

                                                            .content(objectMapper.writeValueAsString(movie)));

                            

                              response.andDo(print())

                                      .andExpect(status().isCreated())

                                      .andExpect(jsonPath("$.name",is(movie.getName())))

                                      .andExpect(jsonPath("$.language",is(movie.getLanguage())));

              }

             

              @Test

              public void testGetAllMovies() throws Exception {

                             Movie movie1=Movie.builder().id(1000).name("Robert")

                                                          .language("Tamil").rating(4).type("action").build();

                             Movie movie2=Movie.builder().id(1001).name("Lost world")

                                                          .language("English").rating(4).type("action").build();

                            

                              List<Movie> list=new ArrayList<>();

                             list.add(movie1);

                             list.add(movie2);

                            

                              given(movieService.getAllMovies()).willReturn(list);

                            

                              ResultActions response=mockMvc.perform(get("/api/movie"));

                             MockHttpServletResponse res=response.andReturn().getResponse();

                             Movie[] mov=new ObjectMapper().readValue(res.getContentAsString(), Movie[].class);

                             assertEquals("Robert",mov[0].getName());

                             assertEquals("English",mov[1].getLanguage());

                                          

              }

             

              @Test

              public void testGetMovieById() throws Exception {

                             Integer id=1000;

                             Movie movie1=Movie.builder().id(1000).name("Robert")

                                                          .language("Tamil").rating(4).type("action").build();

                            

                             given(movieService.getMovieById(id)).willReturn(movie1);

                            

                             ResultActions response=mockMvc.perform(get("/api/movie/{movid}",id));

                             MockHttpServletResponse res=response.andReturn().getResponse();

                             Movie m1=new ObjectMapper().readValue(res.getContentAsString(),Movie.class);

                             assertEquals("Tamil",m1.getLanguage());

                                                         

              }

}
==============================================================

DAY 25


import static org.assertj.core.api.Assertions.assertThat;

import static org.mockito.Mockito.when;

 

import java.util.ArrayList;

import java.util.List;

import java.util.Optional;

 

import org.junit.jupiter.api.Test;

import org.junit.jupiter.api.extension.ExtendWith;

import org.mockito.junit.jupiter.MockitoExtension;

import org.springframework.beans.factory.annotation.Autowired;

import org.springframework.boot.test.context.SpringBootTest;

import org.springframework.boot.test.mock.mockito.MockBean;

 

import com.pack.SpringbootMockito.entity.Movie;

import com.pack.SpringbootMockito.repository.MovieRepository;

import com.pack.SpringbootMockito.service.MovieService;

 

 

@ExtendWith(MockitoExtension.class)

@SpringBootTest  //loads entire application context

public class TestMovieService {

 

              @MockBean

              MovieRepository movieRepo;

             

              @Autowired

              MovieService movieService;

             

              @Test

              public void testCreateMovie() {

                             Movie movie=Movie.builder().id(1001).name("Nun").language("English").type("Horror").rating(4).build();

                             when(movieRepo.save(movie)).thenReturn(movie);

                            assertThat(movieService.createMovie(movie)).isEqualTo(movie);

              }

             

              @Test

              public void testGetAllMovies() {

                             Movie movie1=Movie.builder().id(1001).name("Nun").language("English").type("Horror").rating(4).build();

                             Movie movie2=Movie.builder().id(1002).name("Room").language("English").type("Horror").rating(3).build();

                             List<Movie> list=new ArrayList<>();

                             list.add(movie1);

                             list.add(movie2);

                             when(movieRepo.findAll()).thenReturn(list);

                             assertThat(movieService.getAllMovies()).isEqualTo(list);

              }

             

              @Test

              public void testGetMovieById() {

                             Integer id=1001;

                             Movie movie=Movie.builder().id(1001).name("Nun").language("English").type("Horror").rating(4).build();

                            when(movieRepo.findById(id)).thenReturn(Optional.of(movie));

                            assertThat(movieService.getMovieById(id)).isEqualTo(movie);

              }

}

 

--------------------------------------------------------------------------------------------------------------------------------------------

 

import static org.junit.jupiter.api.Assertions.assertEquals;

 

import java.util.ArrayList;

import java.util.List;

 

import org.junit.jupiter.api.Test;

import org.junit.jupiter.api.extension.ExtendWith;

import org.mockito.junit.jupiter.MockitoExtension;

import org.springframework.beans.factory.annotation.Autowired;

import org.springframework.boot.test.context.SpringBootTest;

 

import com.pack.SpringbootMockito.entity.Movie;

import com.pack.SpringbootMockito.repository.MovieRepository;

 

@ExtendWith(MockitoExtension.class)

@SpringBootTest

public class TestMovieRepository {

 

              @Autowired

              MovieRepository movieRepo;

             

              @Test

              public void testCreateMovie() {

                             Movie movie=Movie.builder().id(1001).name("Nun").language("English").type("Horror").rating(4).build();

                             Movie savedMovie=movieRepo.save(movie);

                             Movie movie1=movieRepo.findById(savedMovie.getId()).get();

                             assertEquals(movie.getId(),movie1.getId());

              }

             

              public void testGetAllMovies() {

                             List<Movie> list=movieRepo.findAll();

                             List<Movie> list1=new ArrayList<>();

                             for(Movie m: list) {

                                           list1.add(m);

                             }

                             assertEquals(list.size(),list1.size());

              }

}